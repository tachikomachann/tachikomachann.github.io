<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tachikomachann.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Less is more">
<meta property="og:type" content="website">
<meta property="og:title" content="タチコマの部屋">
<meta property="og:url" content="https://tachikomachann.github.io/page/2/index.html">
<meta property="og:site_name" content="タチコマの部屋">
<meta property="og:description" content="Less is more">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="タチコマの部屋">
<meta name="twitter:description" content="Less is more">

<link rel="canonical" href="https://tachikomachann.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>タチコマの部屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">タチコマの部屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/02/OAuth2-0面面观/" class="post-title-link" itemprop="url">OAuth2.0面面观</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 20:30:22" itemprop="dateCreated datePublished" datetime="2019-06-02T20:30:22+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="Untitled-fd497460-61c4-4965-8a17-b8713a4c9372.png" alt></p>
<p>只要是接触过各种开放平台的开发者，对于OAuth概念肯定不陌生。但是由于OAuth流程比较复杂，对于刚接触的人来说，容易云里雾里。我之前工作上接触OAuth比较多，本文以OAuth2.0的RFC文档为基础，结合自己以前一些工作上的经验，系统地梳理一下OAuth2.0规范。</p>
<h2 id="What-is-OAuth"><a href="#What-is-OAuth" class="headerlink" title="What is OAuth"></a>What is OAuth</h2><p>关于OAuth的定义，维基百科是这么说的：</p>
<blockquote>
<p>OAuth is an open standard for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords. This mechanism is used by companies such as Amazon, Google, Facebook, Microsoft and Twitter to permit the users to share information about their accounts with third party applications or websites.</p>
</blockquote>
<p>O == Open, Auth == Authorization（授权）, not Authentication（认证）.</p>
<p>首先要明确的是，OAuth是一种授权协议，而非认证协议。通过它，用户可以授权第三方应用访问自己保存在资源服务器器上的资源。当然，如果这些资源是账号信息，第三方服务器也可以基于OAuth实现类似SSO的单点登录，完成登录认证。</p>
<h2 id="OAuth历史"><a href="#OAuth历史" class="headerlink" title="OAuth历史"></a>OAuth历史</h2><p><img src="Untitled-e8759fb4-4901-449a-aea8-9abb58109b82.png" alt></p>
<p>上面这张图基本涵盖了OAuth诞生的相关历史进程。</p>
<p>在2006年，Twitter在开发他们自己的OpenID实现，而当时Ma.gnolia网站需要一个使用OpenID授权访问他们网站资源的方案，双方会面讨论后发现当时并没有一个统一的标准API实现这件事。</p>
<p>上面功能的实现者们于2007年成立了OAuth讨论组，撰写并公布了最早的开放授权（OAuth）草案。这个草案后来得到了Google的关注，最终也一起参与了规范的制定。</p>
<p>在2007年10月，OAuth1.0草案公布。</p>
<p>在2008年11月的IETF第73次会议上，OAuth得到广泛支持，IETF正式为它成立了一个工作组。</p>
<p>2010年，编号为RFC-5849的OAuth1.0 RFC文档发表。</p>
<p>在2012年，OAuth2.0 的RFC-6749, 和Bearer Token 的 RFC-6750相继发表。大多数互联网应用都以此作为授权标准。需要注意的是OAuth2.0与OAuth1.0并不兼容。</p>
<p>虽然IETF的RFC意为征求意见稿(Request for Comment)，但是目前它已经是开放授权的事实标准。</p>
<p>本文后续的一些内容，提炼自IETF的RFC文档，并结合我自己工作中的一些经验总结。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>了解OAuth2.0之前，我们先熟悉几个概念。</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><img src="Untitled-3328dbda-4800-4e0a-8e69-9aeccec4061d.png" alt></p>
<p>OAuth2.0 把整个流程中的参与者分为4种角色：</p>
<ol>
<li>Resource Owner：资源拥有者，通常是我们网站/应用的用户。</li>
<li>Client secret：与Client id 配对的密钥，格式各家实现不用，保证安全性即可。在进行OAuth授权流程时，Client必须提供Client id与 Client secret。如果Client secret发生泄露，出于安全考虑，Authorization Server一般允许注册方重新生成secret.</li>
<li>Client：客户端，一般指第三方应用程序，即资源使用方。比如豆瓣注册时，需要用户的微信头像做豆瓣头像，此时豆瓣就是Client。</li>
<li>Authorization Server：授权服务器，对Client进行授权时验证客户端，用户合法性的节点。Resource Server 和 Authorization Server可能是同一个（比如资源是账号数据时）也可能不同。</li>
</ol>
<h3 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h3><p>首先，Client 想要得到Authorization Server 的授权，需要先注册。比如各种开放平台，需要先由开发者提供网站地址，应用名称，默认重定向地址等信息，才能为其颁发合法的Client id 和 Client Secret 进行OAuth授权。</p>
<ol>
<li>Client id：是 Client 在Authorization Server注册的标志，格式各家实现不同，但是需要全局唯一。一般注册后不会改变，也有实现方喜欢叫App id。</li>
<li>Client secret：与Client id 配对的密钥，格式各家实现不用，保证完全性即可。在进行OAuth授权流程时，Client必须提供Client id与 Client secret。如果Client secret发生泄露，处于安全考虑，Authorization Server一般允许注册方重新生成secret.</li>
<li>User-Agent：一般指用户浏览器，或者APP。</li>
<li>Access token：是完成授权流程后，Client得到的票据，访问Resource Owner的资源时，需要对其进行验证。认证失败Authorization Server将引导Client重新进行OAuth流程。</li>
<li>Refresh token：类似 AccessToken 的票据，用于刷新Access token（不需要重新走OAuth流程）。Refresh token 是可选项，不一定要实现。</li>
</ol>
<p>熟悉这些概念后，我们开始介绍OAuth2.0定义的标准授权流程。</p>
<h2 id="OAuth2-0-Flow"><a href="#OAuth2-0-Flow" class="headerlink" title="OAuth2.0 Flow"></a>OAuth2.0 Flow</h2><p>以下几种OAuth Flow，摘选自RFC相关文档，详情请参考最后引用链接。</p>
<p>为覆盖各种场景，OAuth2.0划分了4种授权流程：</p>
<ol>
<li>Authorization Code：授权码模式，因为需要在各个节点往返三次，俗称3 leg。</li>
<li>Implicit：隐式授权，相对于授权码模式做了简化。 </li>
<li>Resource Owner Password Credentials：密码认证模式。</li>
<li>Client Credentials：客户端认证模式。</li>
</ol>
<p>下面详细介绍这几种模式。</p>
<h3 id="Authorization-Code-Grant"><a href="#Authorization-Code-Grant" class="headerlink" title="Authorization Code Grant"></a>Authorization Code Grant</h3><p>下图描述了一个完整的 Authorization Code 模式授权流程，Client与其他角色的交互通过User-Agent，这里 Client 包含前端和后端服务器。</p>
<pre><code>+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier      +---------------+
|         -+----(A)-- &amp; Redirection URI ----&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
|          |                                 |               |
|         -+----(C)-- Authorization Code ---&lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 (A)  (C)                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&gt;---(D)-- Authorization Code ---------&apos;      |
|  Client |          &amp; Redirection URI                  |
|         |                                             |
|         |&lt;---(E)----- Access Token -------------------&apos;
+---------+       (w/ Optional Refresh Token)
</code></pre><ol>
<li>步骤A：用户在通过User-Agent(浏览器)使用Client时，Client需要访问用户Resource Owner的资源，此时发起了OAuth流程。Client携带客户端认证信息（Client id）、请求资源的范围、本地状态，重定向地址等重定向到Authorization Server，用户看到授权确认页面。</li>
<li>步骤B：用户认证并确认授权信息，Authorization Server判断用户是否合法来进行下一步授权或者返回错误。</li>
<li>步骤C：如果用户合法且同意授权，Authorization Server使用第一步Client提交的重定向地址重定向浏览器，并携带授权码和之前Client提供的本地状态信息。</li>
<li>步骤D：Client 使用授权码找Authorization Server交换access token(处于安全性考虑，一般由Client 的服务端发起)，为了严格验证，这一步除了携带授权码，还需要前面使用的重定向地址。</li>
<li>步骤E：Authorization Server 验证Client提交的授权码是否有效，重定向地址是否与步骤C匹配。如果验证通过，将返回access token和refresh token（可选）给Client。</li>
</ol>
<p>得到 access token后，Client可以在token失效前，访问Resource Server得到已授权的用户资源。OAuth2.0在Client与Resource Server之间，设置了一个授权层（authorization layer），Client 通过得到的授权令牌访问资源，对于资源访问权限、时效在颁发令牌时控制。</p>
<p>流程中几个步骤涉及到的接口：</p>
<p>重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">response_type</td>
<td style="text-align:left">表示授权类型，必选项，此处的值固定为”code”</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">表示客户端的ID，必选项</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，可选项。如果不提供，Authorization Server会使用Client注册时的重定向URI进行重定向。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示申请的权限范围，可选项，多个scope值用空格分开</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。建议使用。</td>
</tr>
</tbody>
</table>
<p>重定向回Client（步骤C）</p>
<p>请求例子：</p>
<pre><code>HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left">表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。建议使用。</td>
</tr>
</tbody>
</table>
<p>从 Authorization Server 获取token（步骤D）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</td>
</tr>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left">表示上一步获得的授权码，必选项。</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">Client在Authorization Server注册后得到的client_id，必选项。</td>
</tr>
</tbody>
</table>
<p>Authorization Server 返回token（步骤E）</p>
<p>响应结果例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">access_token</td>
<td style="text-align:left">表示访问令牌，必选项。</td>
</tr>
<tr>
<td style="text-align:left">token_type</td>
<td style="text-align:left">表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</td>
</tr>
<tr>
<td style="text-align:left">expires_in</td>
<td style="text-align:left">表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left">refresh_token</td>
<td style="text-align:left">表示更新令牌，用来获取下一次的访问令牌，可选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，如果与客户端申请的范围一致，此项可省略。</td>
</tr>
</tbody>
</table>
<h3 id="Implicit-Grant"><a href="#Implicit-Grant" class="headerlink" title="Implicit Grant"></a>Implicit Grant</h3><p>Implicit 授权的流程如下图，与 Authorization Code 相比，少了返回授权码这一步，Authorization Server直接返回token至Client的前端，Client方面没有后端参与。图中的Web-Hosted Client Resource可以认为是Client的前端资源容器，比如前端服务器，APP等。</p>
<pre><code>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier     +---------------+
|         -+----(A)-- &amp; Redirection URI ---&gt;|               |
|  User-   |                                | Authorization |
|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
|          |                                |               |
|          |&lt;---(C)--- Redirection URI ----&lt;|               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  |&lt;---(E)------- Script ---------&lt;|               |
|          |                                +---------------+
+-|--------+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+---------+
|         |
|  Client |
|         |
+---------+
</code></pre><ol>
<li>步骤A：与 Authorization Code流程类似，Client携带客户端认证信息（Client id 和 Secret）、请求资源的范围、本地状态，重定向地址等重定向到Authorization Server，用户看到授权确认页面。</li>
<li>步骤B：用户认证并确认授权信息，Authorization Server判断用户是否合法来进行下一步授权或者返回错误。</li>
<li>步骤C：如果用户合法且同意授权，Authorization Server使用第一步Client提交的重定向地址重定向浏览器，并将token携带在URI Fragment中一并返回。</li>
<li>步骤D：User-Agent 顺着重定向指示向Web-Hosted Client Resource 发起请求（按RFC2616该请求不包含Fragment）。User-Agent 在本地保留Fragment信息。</li>
<li>步骤E：Web-Hosted Client Resource 返回一个网页（通常是带有嵌入式脚本的HTML），该网页能够提取URI中的Fragment和其他参数。</li>
<li>步骤F：在User-Agent中使用上一步提供的脚本提取URL中的token。</li>
<li>步骤G：User-Agent传送token给Client。</li>
</ol>
<p>Implicit 比起 Authorization Code 来说，少了Client使用授权码换Token的过程，而是直接把token提供给User-Agent让Client提取。整个流程中使用URL传递token，不需要Client的服务端参与，且没有严格验证Client信息，安全性欠佳。使用这个方式授权，需要在安全性和便利性之间做好权衡。</p>
<p>流程中几个步骤涉及到的接口：</p>
<p>重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">response_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”token”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">表示客户端的ID，必选项</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，可选项。如果不提供，Authorization Server会使用Client注册时的重定向URI进行重定向。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示申请的权限范围，可选项，多个scope值用空格分开</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</td>
</tr>
</tbody>
</table>
<p>携带token重定向回Client（步骤C）</p>
<p>请求例子：</p>
<pre><code>HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">access_token</td>
<td style="text-align:left">表示访问令牌，必选项。</td>
</tr>
<tr>
<td style="text-align:left">token_type</td>
<td style="text-align:left">表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</td>
</tr>
<tr>
<td style="text-align:left">expires_in</td>
<td style="text-align:left">表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，如果与客户端申请的范围一致，此项可省略。</td>
</tr>
</tbody>
</table>
<p>Implicit Grant  不严格验证Client，因此这里不提供 refresh_token（以防Client不经用户同意，使用refresh_token不断得到授权）。同时Implicit Grant 的access_token 是通过url的hash返回的，不会在网络上传输，但是还是存在泄漏的可能（如User-Agent本身不安全）。</p>
<h3 id="Resource-Owner-Password-Credentials-Grant"><a href="#Resource-Owner-Password-Credentials-Grant" class="headerlink" title="Resource Owner Password Credentials Grant"></a>Resource Owner Password Credentials Grant</h3><p>这种授权方式其实是常见的用户名密码认证方式。使用这种授权的Client必须是高度可信的，比如操作系统。只有当其他的流程不能使用时，才启用这种方式，同时Authorization Server必须特别关注Client确保不会出现安全问题。整个过程中，Client不得保存用户的密码（只能由Client来保证，所以Client必须是高度可信的）。</p>
<pre><code>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     v
     |    Resource Owner
    (A) Password Credentials
     |
     v
+---------+                                  +---------------+
|         |&gt;--(B)---- Resource Owner -------&gt;|               |
|         |         Password Credentials     | Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(C)---- Access Token ---------&lt;|               |
|         |    (w/ Optional Refresh Token)   |               |
+---------+                                  +---------------+
</code></pre><ol>
<li>步骤A：resource owner 提供给Client用户名密码。</li>
<li>步骤B：Client直接使用用户名密码向Authorization Server进行认证，并请求token。</li>
<li>步骤C：Authorization Server认证Client信息和用户名密码，验证通过后返回token。</li>
</ol>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client提交用户名密码请求token（步骤B）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”password”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">username</td>
<td style="text-align:left">表示用户名，必选项。</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">表示用户的密码，必选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，可选项。</td>
</tr>
</tbody>
</table>
<p>Authorization Server返回token信息（步骤C）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式是一样的。</p>
<h3 id="Client-Credentials-Grant"><a href="#Client-Credentials-Grant" class="headerlink" title="Client Credentials Grant"></a>Client Credentials Grant</h3><p>该模式是Client 访问实现与Authorization Server约定好的资源。Client以自己的名义，而不是以用户的名义，向Authorization Server进行认证。严格地说，Client Credentials 模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向Client注册，Client以自己的名义要求Authorization Server提供服务，其实不存在授权问题。</p>
<pre><code>+---------+                                  +---------------+
|         |                                  |               |
|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(B)---- Access Token ---------&lt;|               |
|         |                                  |               |
+---------+                                  +---------------+
</code></pre><ol>
<li>步骤A：Client 向Authorization Server进行身份认证，并请求token。</li>
<li>步骤B：Authorization Server 对 Client信息进行认证，有效则发放token。</li>
</ol>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client申请token（步骤A）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”client_credentials”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，可选项。</td>
</tr>
</tbody>
</table>
<p>这一步Authorization Server 必须验证Client。</p>
<p>Authorization Server返回token信息（步骤B）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式也是一样的。</p>
<h3 id="PKCE-Proof-Key-for-Code-Exchange"><a href="#PKCE-Proof-Key-for-Code-Exchange" class="headerlink" title="PKCE(Proof Key for Code Exchange)"></a>PKCE(Proof Key for Code Exchange)</h3><p>随着无服务端移动应用或SPA的流行，IETF针对Implicit授权提出了优化方案，在RFC-6749的四种Flow之外另外定义了一种更安全的PKCE模式（RFC-7636）。<br>PKCE的流程大概如下:</p>
<pre><code>                                          +-------------------+
                                          |   Authz Server    |
+--------+                                | +---------------+ |
|        |--(A)- Authorization Request ----&gt;|               | |
|        |       + t(code_verifier), t_m  | | Authorization | |
|        |                                | |    Endpoint   | |
|        |&lt;-(B)---- Authorization Code -----|               | |
|        |                                | +---------------+ |
| Client |                                |                   |
|        |                                | +---------------+ |
|        |--(C)-- Access Token Request ----&gt;|               | |
|        |          + code_verifier       | |    Token      | |
|        |                                | |   Endpoint    | |
|        |&lt;-(D)------ Access Token ---------|               | |
+--------+                                | +---------------+ |
</code></pre><p>这里引入了几个新的变量：t_m（摘要算法），code_verifier，code_challenge（即图中经过算法t_m计算后得到的t(code_verifier)参数）</p>
<ol>
<li>Client随机生成一串字符并作URL-Safe的Base64编码处理, 结果用作code_verifier。</li>
<li>将这串字符通过SHA256哈希，并用URL-Safe的Base64编码处理，结果用作code_challenge。</li>
<li>Client使用把code_challenge，请求Authorization Server，获取Authorization Code。（步骤A）</li>
<li>Authorization Server 认证成功后，返回Authorization Code（步骤B）。</li>
<li>Client 把Authorization Code 和code_verifier请求Authorization Server，换取Access Token。</li>
<li>Authorization Server 返回 token。（步骤D）</li>
</ol>
<p><strong>由于中间人不能由code_challenge逆推code_verifier，因此即使中间人截获了code_challenge, Authorization Code等，也无法换取Access Token, 避免了implicit模式的安全问题。</strong></p>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>https://{authorizationServerDomain}/oauth2/default/v1/authorize?client_id=0oabygpxgk9l
XaMgF0h7&amp;response_type=code&amp;scope=openid&amp;redirect_uri=yourApp%3A%2Fcallback&amp;st
ate=state-8600b31f-52d1-4dca-987c-386e3d8967e9&amp;code_challenge_method=S256&amp;code_
challenge=qjrzSW9gMiUgpUvqgEPE4_-8swvyCtfOVvg55o5S_es
</code></pre><p>response_type，client_id，redirect_uri，scope，state 跟implicit 模式是一样的。重点看下其他几个参数。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code_verifier</td>
<td style="text-align:left">一串用来加密的 43 位到 128 位的随机字符串。由 A-Z，a-z，0-9，还有符号 -._~ 生成。</td>
</tr>
<tr>
<td style="text-align:left">code_challenge</td>
<td style="text-align:left">由 code_verifier 来生成，如果设备支持加密，则加密方式为：BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))。如果不支持，则直接使用 code_verifier。</td>
</tr>
<tr>
<td style="text-align:left">code_challenge_method</td>
<td style="text-align:left">生成 code_challenge 所用方法，分为 SHA256 和 plain。前者是指 SHA256 方法加密生成，后者是指直接使用 code_verifier，即不加密。</td>
</tr>
</tbody>
</table>
<p>Authorization Server返回token信息（步骤B）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式也是一样的。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>对于token（Access Token和Refresh Token）需要使用什么样的格式，其实没有硬性要求，不同平台有不同的实现方式。这里列举两种常见的token规范，Bearer Token和JWT。</p>
<h3 id="Bearer-Token"><a href="#Bearer-Token" class="headerlink" title="Bearer Token"></a>Bearer Token</h3><p>OAuth 诞生时就已经定义了两种token格式：Bearer Token 和 Mac Token，Mac 主要使用在无https的环境下，由于OAuth2.0已经要求所有参与者必须使用HTTPS，所以Mac格式不在我们今天讨论范围。Bearer Token由RFC-6750定义。</p>
<p>Bearer Token 格式用BNF范式表示就是：</p>
<pre><code>b64token    = 1*( ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;
credentials = &quot;Bearer&quot; 1*SP b64token
</code></pre><p>换成程序员比较容易理解的正则表达式就是：</p>
<pre><code>b64token = [0-9a-zA-Z-._~+/]+=
credentials =  Bearer\s([0-9a-zA-Z-._~+/]+=)+
</code></pre><p>所以所谓的Bearer Token就是以数字、大小写字母、破折号、小数点、下划线、波浪线、加号、正斜杠、等号结尾组成的Base64编码字符串。在HTTP传输过程中，需要以’Bearer ‘作为前缀标识。</p>
<p><strong>Bearer Token 的三种传输方式</strong></p>
<p>RFC-6750定义了三种传输Bearer Token 的方式，优先级依次递减：</p>
<p><strong>Authorization Request Header Field（使用HTTP Header的Authorization字段传递）</strong></p>
<pre><code>GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM
</code></pre><p><strong>Form-Encoded Body Parameter（使用表单参数传递）</strong></p>
<pre><code>POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=mF_9.B5f-4.1JqM
</code></pre><p><strong>URI Query Parameter（使用URI参数传递）</strong></p>
<pre><code>GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1
Host: server.example.com
</code></pre><p>由于Cookie容易被CSRF攻击，不建议采用cookie的方式传输token。<br>尽量不要用URI参数的方法，因为浏览器历史记录、服务器日志等可能泄露URI上的机密信息。</p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（JSON Web Token）是近几年移动端常用的token，它可以直接将一些信息编码传递，对客户端更友好。使用JWT有以下有点：</p>
<ol>
<li>验证token 不需要另外的缓存或者数据库，通过约定好的加密方式解密就行。</li>
<li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</li>
<li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息, 所以它易于应用的扩展。</li>
</ol>
<p>使用JWT也必须注意一些问题：</p>
<ol>
<li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好secret私钥，该私钥非常重要。</li>
<li>如果可以，请使用https协议传递JWT。</li>
</ol>
<p>JWT也有自己的RFC规范RFC-7519，这里简单介绍一下它的格式。详细请参考文末的RFC链接。</p>
<p><img src="Untitled-2a5aa9d0-2e52-43d2-9a74-ef24c45f72ac.png" alt></p>
<p>JWT的格式很简单，一个JWT字符串分为Header，Payload，Signature三部分，他们的原始字符串经过编码后由小数点分隔连接起来。</p>
<p>Header记录着token类型和摘要算法，这里的明文最后要经过Base64URL编码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Payload记录着业务信息和用户数据（非敏感），字段可以根据需求自定义，<strong>处于安全性考虑，实现方会再加上expire过期时间字段控制生命周期</strong>。这里的明文同样也要经过Base64URL编码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Signature是Header和Payload经过摘要算法处理后的签名信息，使用的摘要算法需要同Header中alg属性一致，这里是HS256。secret是加密需要的密钥，使用对称加密算法的话密钥泄漏影响较大。如果使用非对称加密算法（如RSA256），使用的是公钥验证签名，风险就小很多：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>连接编码后的三个部分，就得到一个JWT字符串：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
</code></pre><p>所以当Server端颁发JWT后，Client就可以根据约定好的secret，摘要算法验证Signature并提取Payload信息。</p>
<h2 id="OAuth-面临的安全问题"><a href="#OAuth-面临的安全问题" class="headerlink" title="OAuth 面临的安全问题"></a>OAuth 面临的安全问题</h2><p>OAuth2.0 作为一个授权协议，安全问题尤为重要。OAuth大规模应用的这些年来，主要的安全问题可以分为以下几类：</p>
<ol>
<li>Client Authentication（客户端错误认证），作为Client的开发者，必须保护好自己的client_id client_secret，谨防盗用。</li>
<li>Code or Token Steal（票据窃取），OAuth 是票据协议，无法区分使用票据的人是否合法。所以作为Authorization Server，必须对token的失效机制做好控制(如合理的失效时间，限制Code只能用一次，允许用户管理自己已授权的token)。作为Client，必须确保用户授权的token不被采集（最常见的问题就是在log中记录access token）</li>
<li>Cross-Site Request Forgery(CSRF攻击)，Authorization Code Grant模式流程较长，存在CSRF隐患。</li>
<li>Authorization Code Redirection URI Manipulation（重定向地址篡改），重定向地址篡改是钓鱼网站常用的攻击手段。</li>
</ol>
<p>前面两种是任何认证授权系统都需要考虑的安全问题，这里重点介绍下后面两种跟OAuth流程比较相关的安全问题。</p>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>在OAuth2.0流程中实施CSRF攻击的流程如下：</p>
<p><img src="Untitled-4dc8306d-39bc-4d5d-937c-2e4ae4645294.png" alt></p>
<p><strong>原理</strong></p>
<ol>
<li>攻击者预先准备好使用自己账号授权生成的 authorization code 的回调地址，引诱用户点击。</li>
<li>用户点击后，变成使用攻击者的账号完成Oauth 流程得到token。</li>
<li>在的第三方app绑定账号的场景，攻击者就可以使用自己的账号完成OAuth登陆用户的第三方app。</li>
</ol>
<p><strong>防范措施</strong></p>
<p>要防止这样的攻击其实很容易，使用RFC规范中推荐的state参数即可，但是由于增加了开发工作量，很多开发者使用OAuth2.0时，经常忽略这个参数。具体细节如下：</p>
<ol>
<li>在 Authorization Code Grant或者implicit Grant流程的第一步，调用/authorize接口时，带上state参数，state的值由Client指定，生成规则需保证足够随机又有一定业务含义，他人无法轻易假冒。</li>
<li>Client 需要保存state参数。</li>
<li>在Authorization Server 认证成功重定向回Client时，会将state原样带回，此时Client需要验证state参数是否一致。</li>
</ol>
<h3 id="Authorization-Code-流程重定向地址篡改"><a href="#Authorization-Code-流程重定向地址篡改" class="headerlink" title="Authorization Code 流程重定向地址篡改"></a>Authorization Code 流程重定向地址篡改</h3><p><img src="Untitled-c5f08367-0a87-4b30-a497-d1194581e665.png" alt></p>
<p>对重定向地址检查也是一个时常被忽略的安全弱点。</p>
<p><strong>原理</strong></p>
<ol>
<li>对于一个正常的第三方Client应用A，攻击者自己也作为一个Client，伪造一个应用A的/authorize请求的链接，其中redirect_uri指向的是攻击者的Client。</li>
<li>攻击者诱导用户点击伪造的链接，发起OAuth2.0的Authorization Code Grant流程。</li>
<li>用户完成认证后，Authorization Server 携带Code重定向回攻击者Client。</li>
<li>攻击者准备一个自己的Code，将上一步应用A的Code替换，伪造一条应用A的回调请求返回给应用A。（此时Code被替换成了攻击者的Code）</li>
<li>应用A的Client在不清楚Code被替换的情况下，继续完成Authorization Code Grant流程，使用攻击者的Code换取Access Token。</li>
</ol>
<p>此时用户走完OAuth流程，但是在应用A上得到的却是攻击者帐号的授权。大家会觉得，这样有什么问题，又不是用户的授权泄漏。这种攻击方式可以针对绑定帐号的场景，比如用户本来要将豆瓣帐号与微博帐号关联，使用微博的OAuth授权来登陆豆瓣。而被这样钓鱼以后，自己的豆瓣帐号绑定的是攻击者的微博帐号，此时攻击者就可以用他的微博帐号登陆用户的豆瓣帐号了。</p>
<p><strong>防范方法</strong></p>
<ol>
<li>Client 注册时，需要开发者提供域名与Client绑定。</li>
<li>Authorization Server对/authorize 接口验证的redirect_uri 参数验证，确认与Client注册时提供的域名一致。</li>
<li>Authorization Server对/access_token 接口的redirect_uri 参数进行验证，保证与Client发起 /authorize请求时的redirect_uri一致。</li>
<li>对于Authorization Server的Code换token接口，可以要求Client提供client_id和secret，校验此时的code是否产生自同一个client_id。</li>
</ol>
<p>对于上面提到的CSRF和钓鱼攻击，Client方面如果增加一些授权成功后的提示给用户（比如平台成功与xxx帐号绑定），可以避免用户无意识地授权的情况发生。上面的例子只是简单展示了OAuth授权中需要开发者关注的安全细节，关于OAuth安全想要了解更多，可以参考文末的OAuth安全指南。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>OAuth2.0 规范将参与者划分为 Resource Owner，Resource Server，Client，Authorization Server四种角色。</li>
<li>RFC-6749定义了四种OAuth2.0 Grant Flow：Authorization Code Grant，Implicit Grant，Resource Owner Password Credentials Grant，Client Credentials Grant。其中前两种是比较常用的OAuth2.0授权模式。</li>
<li>对于移动端APP或者SPA应用，可以考虑使用PKCE模式减少Implicit Grant的安全风险。</li>
<li>对于Token的格式，建议使用Bearer Token或者JWT。</li>
<li>由于OAuth2.0的Flow步骤较长，不管是Client端还是Authorization Server端，在使用OAuth2.0的时候，最好严格按照RFC规范执行，可以最大程度地减少安全隐患。同时也要注意业界关于OAuth漏洞的披露，及时修复漏洞。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li>OAuth2.0: <a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a></li>
<li>OAuth2.0(RFC-6749): <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a></li>
<li>PKCE(RFC-7636): <a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7636</a></li>
<li>Bearer token(RFC-6750): <a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6750</a></li>
<li>JWT(RFC-7519): <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a></li>
<li>乌云平台（备份）OAuth安全指南: <a href="http://drops.xmd5.com/static/drops/papers-1989.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/papers-1989.html</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2019/01/20/Effective Java 3rd edition 读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/20/Effective Java 3rd edition 读书笔记/" class="post-title-link" itemprop="url">Effective Java 3rd edition 读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-20 19:20:00" itemprop="dateCreated datePublished" datetime="2019-01-20T19:20:00+08:00">2019-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近把去年出版的 Effective Java 3rd Edition 的新章节读完了，把笔记统一整理一下。</p>
<h2 id="Lambdas-and-Streams"><a href="#Lambdas-and-Streams" class="headerlink" title="Lambdas and Streams"></a>Lambdas and Streams</h2><h3 id="Item-42-Prefer-lambdas-to-anonymous-class"><a href="#Item-42-Prefer-lambdas-to-anonymous-class" class="headerlink" title="Item 42: Prefer lambdas to anonymous class"></a>Item 42: Prefer lambdas to anonymous class</h3><p>Java 8 以前，模板方法、函数方法基本是用匿名类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before JDK1.8  use anonymous object</span></span><br><span class="line"><span class="comment">// Anonymous class instance as a function object - obsolete! </span></span><br><span class="line">Collections.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> Integer.compare(s1.length(), s2.length()); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Java 8 开始，可以使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before JDK1.8  use anonymous object</span></span><br><span class="line"><span class="comment">// Anonymous class instance as a function object - obsolete! </span></span><br><span class="line">Collections.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123; </span><br><span class="line">		<span class="keyword">return</span> Integer.compare(s1.length(), s2.length()); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Java 8 中的 lambda 表达式时基于函数式接口（Function Interface），它就是一个<strong>有且仅有一个抽象方法</strong>，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为<br>lambda 表达式。</p>
<p>比如 上面Collections.sort中的 Comparator 变量，它的函数式接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        list.sort(c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// other method …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以从Java 8 开始，不要创建一个匿名内部类作为函数对象，除非函数式方法入参没有定义函数式接口。</p>
<h3 id="Item-43-Prefer-method-references-to-lambdas"><a href="#Item-43-Prefer-method-references-to-lambdas" class="headerlink" title="Item 43: Prefer method references to lambdas"></a><strong>Item 43: Prefer method references to lambdas</strong></h3><p>Java 8 开始提供一种比 lambda 更简洁的方式作为函数对象：方法引用（method references）</p>
<p>方法引用和 lambda 表达式对比：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method reference</span></span><br><span class="line">map.merge(key, <span class="number">1</span>, Integer::sum);</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">map.merge(key, <span class="number">1</span>, (count, incr) -&gt; count + incr);</span><br></pre></td></tr></table></figure>
<p>目前方法引用唯一用途是用来简化 lambda 表达式，用方法名来代替 lambda。</p>
<p>方法引用的几种形式：</p>
<p><strong>引用静态方法</strong> </p>
<p>ContainingClass::staticMethodName </p>
<p>例子: String::valueOf，对应的Lambda：(s) -&gt; String.valueOf(s) </p>
<p>比较容易理解，和静态方法调用相比，只是把.换为::</p>
<p><strong>引用特定对象的实例方法</strong> </p>
<p>containingObject::instanceMethodName </p>
<p>例子: x::toString，对应的Lambda：() -&gt; this.toString() </p>
<p>与引用静态方法相比，都换为实例的而已。</p>
<p><strong>引用特定类型的任意对象的实例方法</strong> </p>
<p>ContainingType::methodName </p>
<p>例子: String::toString，对应的Lambda：(s) -&gt; s.toString() </p>
<p>太难以理解了。难以理解的东西，也难以维护。建议还是不要用该种方法引用。 </p>
<p>实例方法要通过对象来调用，方法引用对应Lambda，Lambda的第一个参数会成为调用实例方法的对象。</p>
<p><strong>引用构造函数</strong> </p>
<p>ClassName::new </p>
<p>例子: String::new，对应的Lambda：() -&gt; new String() </p>
<p>构造函数本质上是静态方法，只是方法名字比较特殊。</p>
<p>有些情况下，使用方法引用的代码 会比 lambda 更长</p>
<p>比如这个在 GoshThisClassNameIsHumongous 类中的方法: </p>
<p>用方法引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.execute(GoshThisClassNameIsHumongous::action);</span><br></pre></td></tr></table></figure>
<p>等价的 lambda 是: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service.execute(() -&gt; action());</span><br></pre></td></tr></table></figure>
<p>下面是各种方法引用的例子：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Method ref Type</th>
<th>Example</th>
<th>Lambda Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Static</td>
<td>Integer::parseInt</td>
<td>str -&gt; Inter.parseInt(str)</td>
</tr>
<tr>
<td style="text-align:left">Bound</td>
<td>Instant.now()::isAfter</td>
<td>Instant then = Instant.now();<br>t -&gt; then.isAfter(t)</td>
</tr>
<tr>
<td style="text-align:left">Unbound</td>
<td>String::toLowerCase</td>
<td>str -&gt; str.toLowerCase()</td>
</tr>
<tr>
<td style="text-align:left">Class Constructor</td>
<td>TreeMap&lt;K, V&gt; :: new</td>
<td>() -&gt; new TreeMap&lt;K, V&gt;</td>
</tr>
<tr>
<td style="text-align:left">Array Constructor</td>
<td>int[] :: new</td>
<td>len -&gt; new int[len]</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>： Bound unbound reference method 用法语义比较模糊，感觉用 Lambda 描述更清楚。</p>
<p><strong>总而言之，当方法引用更简单明了时，就用它，否则就用 lambda。</strong></p>
<h3 id="Item-44-Favor-the-use-of-standard-functional-interfaces"><a href="#Item-44-Favor-the-use-of-standard-functional-interfaces" class="headerlink" title="Item 44: Favor the use of standard functional interfaces"></a>Item 44: Favor the use of standard functional interfaces</h3><p>JDK 包中已经默认提供了多种函数式接口，所以尽量使用自带的而不是自己写函数式接口。</p>
<p>比如下面的例子，我们自定义了一个函数式接口，需要让重写的类有一一个 remove 的默认方法，入参是 map自己的引用和eledest元素，使用fuction interface可以先定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unnecessary functional interface; use a standard one instead. </span></span><br><span class="line"><span class="meta">@FunctionalInterface</span> <span class="class"><span class="keyword">interface</span> <span class="title">EldestEntryRemovalFunction</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Map&lt;K,V&gt; map, Map.Entry&lt;K,V&gt; eldest)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个接口，JDK已经有默认实现，就是BiPredicate 接口。</p>
<h4 id="标准函数式接口分类"><a href="#标准函数式接口分类" class="headerlink" title="标准函数式接口分类"></a>标准函数式接口分类</h4><p>Java 自带的函数式接口分为几类：Operator，Predicate，Function，Supplier，Consumer。</p>
<ol>
<li><p>Operator 接口表示入参和返回值是同一种类型的函数，比如下面代表一元、二元运算的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UnaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">UnaryOperator&lt;T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BinaryOperator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>,<span class="title">T</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">minBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &lt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BinaryOperator&lt;T&gt; <span class="title">maxBy</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(comparator);</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; comparator.compare(a, b) &gt;= <span class="number">0</span> ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>Predicate 有些地方叫做谓词函数，用来表示返回值是boolean 的函数，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Function 类型的函数接口表示入参和返回值不同类型的函数，意为将参数T传给一个函数，返回R。即 R = Function(T)，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Supplier 类型的接口，表示一个没有入参，有返回值的函数，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Supplier 常用于 Stream计算中new 对象。</p>
</li>
<li><p>Consumer 类型的函数接口表示接受一个泛型参数，但是不返回数据，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="FunctionalInterface-注解"><a href="#FunctionalInterface-注解" class="headerlink" title="@FunctionalInterface  注解"></a>@FunctionalInterface  注解</h4><p>@FunctionalInterface 有点像 @Override 注解，注释告诉编译器这是个函数式接口，没有任何功能上的作用。只有一个抽象方法的接口，不使用这个注解也是函数式接口。</p>
<p>需要函数式接口时，先看一下Java 提供的标准接口能否满足，不满足再自己实现，实现时最好遵循标准函数式接口的定义风格。</p>
<h3 id="Item-45-Use-streams-judiciously"><a href="#Item-45-Use-streams-judiciously" class="headerlink" title="Item 45: Use streams judiciously"></a>Item 45: Use streams judiciously</h3><h4 id="一些-stream-API-的概念"><a href="#一些-stream-API-的概念" class="headerlink" title="一些 stream API 的概念"></a>一些 stream API 的概念</h4><p>stream API 里有两种抽象概念: </p>
<ol>
<li>the stream: 表示Java 中的各种集合</li>
<li>stream pipe-line: 表示对于这些集合的多重计算操作，有0个或多个 intermediate operations 一个 terminal<br>operation 组成。 intermediate operations 从一个stream传到另一个stream，terminal operation 对接最后一个 intermediate operations，对stream做最后一次操作（一般是排序、打印、转换集合结果等操作）。</li>
</ol>
<p>Stream pipelines 是懒式（lazily）执行的，只有当碰到 terminal operations 时，前面所有的 intermediate operations 才会执行。不带 terminal operations的stream操作是静默的，永远不会执行。</p>
<p>stream api 是流式的。</p>
<p>默认情况下stream pipleline 是串行（squentially）执行的</p>
<h4 id="过度使用-stream-让程序难以阅读和维护"><a href="#过度使用-stream-让程序难以阅读和维护" class="headerlink" title="过度使用 stream 让程序难以阅读和维护"></a>过度使用 stream 让程序难以阅读和维护</h4><p>在没有显示类型的情况下，合适的参数命名是保持stream 流有良好可读性的关键。</p>
<p><strong>避免使用 stream去处理字符（char）数据</strong> </p>
<p>例如： </p>
<p><code>&quot;Hello world!&quot;.chars().forEach(System.out::print);</code>  中  <code>&quot;Hello world!&quot;.chars()</code>返回的是<code>int[]</code>数组的stream，所以输出的<strong>不是 Hello world!</strong>而是 <strong>7210110810811132119i11111410810033</strong>。因为stream API中只支持 int long double三种primitive ype 的stream，没有char的stream。</p>
<p><strong>只有在值得这么做的情况下，才需要使用sream重构已存在的代码或在新代码中使用sream。</strong>否则容易引入新问题。</p>
<h4 id="几种适合使用stream-api的场景"><a href="#几种适合使用stream-api的场景" class="headerlink" title="几种适合使用stream api的场景"></a>几种适合使用stream api的场景</h4><ol>
<li>统一转换元素序列（如集合中的元素类型）。</li>
<li>过滤元素序列。</li>
<li>对序列元素进行单一聚合操作（如计算和，最小值，连接等）</li>
<li>将序列元素转化为集合，或者以特定条件为它们分组。</li>
<li>以指定条件搜索序列元素。</li>
</ol>
<p><strong>当不知道是否需要使用sream时，两种方案都尝试，看哪个更合适。</strong></p>
<h3 id="Item-46-Prefer-side-effect-free-functions-in-streams-（没有副作用）"><a href="#Item-46-Prefer-side-effect-free-functions-in-streams-（没有副作用）" class="headerlink" title="Item 46: Prefer side-effect-free functions in streams  （没有副作用）"></a>Item 46: Prefer side-effect-free functions in streams  （没有副作用）</h3><p>尽量把<strong>foreach</strong> 操作用于输出stream结果，而不是计算逻辑。</p>
<p>总的来说，stream 的流式编程是没有副作用（side-effect-free）的函数对象。</p>
<p>为了正确使用 stream，必须知道 collectors 操作，它用于产生输出集合。几个重要的collectors 工厂是：<strong>toList, toSet, toMap, groupingBy, joining.</strong></p>
<h3 id="Item-47-Prefer-Collection-to-Stream-as-a-return-type"><a href="#Item-47-Prefer-Collection-to-Stream-as-a-return-type" class="headerlink" title="Item 47: Prefer Collection to Stream as a return type"></a><strong>Item 47: Prefer Collection to Stream as a return type</strong></h3><p>Collection 和它的子类最适合作为返回序列数据的方法的返回值类型。Stream 没有继承或实现 Interable 接口，所以它不能使用 for-each 遍历，所以当某个方法需要返回序列时，优先使用 Collection 返回而不是 Stream。<strong>因为Collection 接口不仅可以被for-each遍历，它还有一个sream方法。</strong>你的方法的调用方可能需要返回的序列结果进行sream运算，或者仅仅只要遍历访问它。</p>
<h3 id="Item-48-Use-caution-when-making-streams-parallel"><a href="#Item-48-Use-caution-when-making-streams-parallel" class="headerlink" title="Item 48: Use caution when making streams parallel"></a><strong>Item 48: Use caution when making streams parallel</strong></h3><p>在并发编程中，违反安全性和活跃度（liveness）的情况是没法避免的，stream 的 parallel 也不例外。</p>
<p>看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Stream-based program to generate the first 20 Mersenne primes </span></span><br><span class="line"><span class="comment">// if change to parallel invoke, it will let cpu usage to 90 percent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span><br><span class="line">        .filter(mersenne -&gt; mersenne.isProbablePrime(<span class="number">50</span>)).limit(<span class="number">20</span>)</span><br><span class="line">        .forEach(System.out::println); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">static</span> Stream&lt;BigInteger&gt; <span class="title">primes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.iterate(TWO, BigInteger::nextProbablePrime); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如源代码是<code>Stream.iterate</code>，或者有使用limit()，再使用 parallel 并行化一个stream pipeline 不大可能提高性能。<strong>所以不要随意地使用 parallel 来并行化 stream 计算。</strong></p>
<p>作为一个规则，在以下类型数据上使用stream parallel 比较容易获得性能收益：ArrayList, HashMap, HashSet, and ConcurrentHashMap instances; arrays; int ranges; and long ranges. 因为<strong>这些数据结构易于拆分子任务，且有较好的存储局部性（locality of reference），所以能在 stream 的并行任务上获得较好效果。</strong></p>
<p>局部性原理可以参考：</p>
<ol>
<li><a href="https://www.zhihu.com/question/25142664" target="_blank" rel="noopener">https://www.zhihu.com/question/25142664</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30127242" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30127242</a></li>
</ol>
<p>如果自己定义了 Stream，Iterable，Collection 接口的接口实现，想要在使用parallel时实现好的性能，需要重写 <strong>spliterator</strong> 方法。</p>
<p>在正确使用的前提下，使用 parallel 处理stream 流，可以得到近似处理器核心数的线性性能提升。某些领域，比如机器学习和数据处理，特别适合这种性能提升。</p>
<p>总的来说，不要尝试使用parallel处理stream，除非你有足够的理由去保证这么做能大幅提高性能并保证程序正确性。<strong>确保你的代码在使用parallel后仍然正确。</strong></p>
<h2 id="Optionals"><a href="#Optionals" class="headerlink" title="Optionals"></a>Optionals</h2><p>Java 8 中新增的 Optional 容器类，它封装了可能为null的对象，强制使用方在使用时进行检查，防止NPE问题。</p>
<p>容器类型（<strong>collections, maps, streams, arrays, and optionals</strong> ）不应该被包换到Optional对象中。</p>
<p>当你的方法可能没有返回值时，你应该使用Optional<t>作为返回值类型，这样调用方必须处理没有返回值的情况，避免了NPE问题。</t></p>
<p><strong>不可以用 Optional 去包装原始类型（Boolean, Byte, Character, Short, and Float）</strong>，因为 Optional 会对其进行两次装箱（boxing）。这种情况应该直接使用 <strong>OptionalInt, OptionalLong, and OptionalDouble</strong>。</p>
<p>不要使用Optional对象最为Map的key或者数组的元素。</p>
<p>因为涉及的装箱拆箱操作，对于性能要求严苛的方法，还是使用返回null的方式处理控制比较合适。</p>
<h2 id="Default-methods-in-interfaces"><a href="#Default-methods-in-interfaces" class="headerlink" title="Default methods in interfaces"></a>Default methods in interfaces</h2><p>Java 8中引入默认方法是为了让老接口支持lambda表达式。在老接口中添加默认方法，这些接口的实现类不会在编译器报错。 </p>
<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><h3 id="Item-9-Prefer-try-with-resources-to-try-finally"><a href="#Item-9-Prefer-try-with-resources-to-try-finally" class="headerlink" title="Item  9: Prefer try-with-resources to try-finally"></a>Item  9: Prefer try-with-resources to try-finally</h3><p>Java 7 以后，应该总是使用  try-with-resources 方式而不是 try-finally 方式处理资源操作。</p>
<p>自动关闭资源的语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources! </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">	<span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader( </span><br><span class="line">	<span class="keyword">new</span> FileReader(path))) &#123; </span><br><span class="line">	<span class="keyword">return</span> br.readLine(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要使用 try-with-resources 语法，资源类必须实现 AutoCloseable   接口。</strong></p>
<h2 id="safeVarags"><a href="#safeVarags" class="headerlink" title="@safeVarags"></a>@safeVarags</h2><p>混用泛型和可变参数时，可能存在安全问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Mixing generics and varargs can violate type safety! </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dangerous</span><span class="params">(List&lt;String&gt;... stringLists)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; intList = List.of(<span class="number">42</span>);</span><br><span class="line">	Object[] objects = stringLists;</span><br><span class="line">	objects[<span class="number">0</span>] = intList;</span><br><span class="line">	<span class="comment">// Heap pollution</span></span><br><span class="line">	String s = stringLists[<span class="number">0</span>].get(<span class="number">0</span>); <span class="comment">// ClassCastException </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存一个值到泛型的可变参数数组中是不安全的，编译器也会提出警告：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Warning look like <span class="keyword">this</span>:</span><br><span class="line">warning: [unchecked] Possible heap pollution from </span><br><span class="line">    parameterized vararg type List&lt;String&gt;</span><br></pre></td></tr></table></figure>
<p><strong>@SafeVarargs</strong>  提供了一种声明，表示该方法的作者保证该方法是类型安全的，编译器会忽略安全检查，不显示警告。</p>
<p>只要有混用泛型和可变参数的方法，都要声明<strong>@SafeVarargs</strong> ，同时作者必须保证方法内部不会出现上面例子的Heap pollution 的类型安全问题。</p>
<p>以下情况的可变参数方法是安全的：</p>
<ol>
<li>不在可变参数数组中保存任何数据</li>
<li>让可变参数数组的数据对非信任代码不可见。</li>
</ol>
<p>@SafeVarargs  只在费重载方法中有效，且java 9之前只能用静态方法。java9中添加了私有方法的使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2018/11/17/Practical Vim 读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/17/Practical Vim 读书笔记/" class="post-title-link" itemprop="url">Practical Vim 读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-17 19:34:00" itemprop="dateCreated datePublished" datetime="2018-11-17T19:34:00+08:00">2018-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>刚工作的时候，看了王垠的一篇《编辑器之神和神之编辑器》，便落入了使用vim的深坑。工作了那么多年发现每个一段时间重新看vim东西总能学到新的知识，最近快速读完了《Practical Vim》,在这里把一些以前没注意的小技巧再重新整理一下。</p>
<h2 id="normal-mode"><a href="#normal-mode" class="headerlink" title="normal mode"></a>normal mode</h2><ul>
<li><code>R</code>进入逐字替换</li>
<li>用<code>f{char}</code>搜索某个字符（比如c），按<code>;</code>可以跳到下一个c位置，按<code>,</code>跳到上一个c</li>
<li>使用相对行号时，如何删除当前行开始向下数3行的内容? <code>d3j</code></li>
<li><code>q/</code>  查看使用<code>/</code>搜索过的历史命令</li>
<li><code>q:</code> 查看 ex 命令历史</li>
<li><code>m{char}</code>  标记位置，<code>`{char}</code> 调整到标记位置，其中<code>{char}</code>用<strong>小写字母</strong>是文件内标记，用<strong>大写字母</strong>是全局标记（可以在文件之间跳转）</li>
<li><strong>0（数字0）</strong>是复制专用寄存器，只有y命令会覆盖它，使用y命令后，”0p可以黏贴寄存器内容。覆盖无名寄存器的操作（x,c,d等）不会覆盖0寄存器</li>
</ul>
<h2 id="insert-mode"><a href="#insert-mode" class="headerlink" title="insert mode"></a>insert mode</h2><ul>
<li><code>&lt;C-r&gt;{register}</code>   直接输出寄存器的值,比如<code>&lt;C-r&gt;a</code>是输出a寄存器内容</li>
<li><code>&lt;C-r&gt;=6*35&lt;CR&gt;</code>  使用表达式寄存器=，计算6*35的值并输出</li>
</ul>
<h2 id="virtual-mode"><a href="#virtual-mode" class="headerlink" title="virtual mode"></a>virtual mode</h2><ul>
<li><code>v</code>高亮选择文本，<code>gv</code>重选上次高亮选区</li>
<li>高亮选中文本后，按<code>o</code>可以将光标在高亮文本起始末尾跳转，方便调整高亮文本</li>
</ul>
<h2 id="Ex-command-mode"><a href="#Ex-command-mode" class="headerlink" title="Ex command mode"></a>Ex command mode</h2><ul>
<li><code>[range] m {address}</code>  把[range] 范围的文本移动到{address}</li>
<li><code>[range] t {address}</code>  把[range] 范围的文本复制到{address}</li>
<li><code>&lt;C-r&gt;{register}</code> 在命令行黏贴寄存器内容</li>
<li><code>[range] normal {command</code>} 使用命令行执行普通模式命令，如 <code>% normal A;</code>  会在所有行后面追加字符<strong>;</strong></li>
<li>重复上一次执行的Ex 命令，使用 <code>@:</code></li>
<li><code>&lt;C-d&gt;</code> 显示可用命令列表，<code>Tab</code>补全命令</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code>插入当前光标下的单词到编辑的command中</li>
</ul>
<p>[range]  范围语法支持：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>文本第一行</td>
</tr>
<tr>
<td>$</td>
<td>文本的最后一行</td>
</tr>
<tr>
<td>0</td>
<td>虚拟行，位于文本第一行上方</td>
</tr>
<tr>
<td>.</td>
<td>光标所在行</td>
</tr>
<tr>
<td>‘m</td>
<td>位置标记m所在行</td>
</tr>
<tr>
<td>‘&lt;</td>
<td>高亮选区的起始行</td>
</tr>
<tr>
<td>‘&gt;</td>
<td>高亮选区的结束行</td>
</tr>
<tr>
<td>%</td>
<td>整个文件</td>
</tr>
</tbody>
</table>
<ol>
<li>允许使用<code>+{number}</code>，<code>-{number}</code>对[range]进行偏移</li>
<li>[range] 也支持使用模式匹配</li>
</ol>
<h2 id="Macro-（宏）"><a href="#Macro-（宏）" class="headerlink" title="Macro （宏）"></a>Macro （宏）</h2><p>录制宏:</p>
<ol>
<li><code>q{register}</code> 开启录制</li>
<li>录入宏的内容</li>
<li><code>q</code>结束录制</li>
</ol>
<p>调用宏：<code>@{register}</code><br>批量调用： <code>n@{register}</code>   ,这里n是执行宏的次数<br>向录制好的宏追加内容： 用 <code>q{register大写}</code> 开始录制，录制后的内容会追加到原来的宏后面。比如原来用 <code>qa</code> 录制了 <code>dwi</code> 操作，想要再后面加<code>j</code>，可以：</p>
<ol>
<li>用 <code>qA</code> 开启宏a的追加</li>
<li>录制<code>j</code></li>
<li>按<code>q</code>结束录制</li>
<li>此时<code>@a</code>执行的操作就是<code>dwij</code></li>
</ol>
<p>编辑宏:<br>宏用的寄存器和复制黏贴的寄存器是一样的，需要编辑好录制的宏，可以先将寄存器输出，编辑后复制到寄存器中，继续用<code>@{register}</code>执行宏。比如原来寄存器<code>a</code>录制的宏是<code>dwij</code>，现在想要改成<code>dwi2j</code>，可以：</p>
<ol>
<li>在normal mode下，”ap 黏贴出宏内容 dwij </li>
<li>将内容改成 dwi2j</li>
<li>选中文本，y”a 覆盖寄存器a内容</li>
<li>再执行@a，操作就是 dwi2j了</li>
</ol>
<h2 id="Pattern-模式匹配"><a href="#Pattern-模式匹配" class="headerlink" title="Pattern 模式匹配"></a>Pattern 模式匹配</h2><p>vim 的 search(搜索)，substitute(替换)命令都支持Pattern，也就是正则表达式匹配<br>默认情况下，<code>/</code> 搜索模式的正则表达式，正则表达式的元字符 <code>.*()</code>等，都需要加<code>\</code>转义，也就是在默认情况下<code>/.*</code>搜索的是 <code>.*</code>字符串，而不是<strong>任意个</strong>字符</p>
<p>magic:<br>在搜索表达式前加<code>\m</code>使用magic功能，除了 <code>$.*^</code>之外的元字符要加反斜杠，如<code>\m.*</code>搜索的就是任意字符，若不是<code>.*</code>字符串</p>
<p>very magic:<br>在搜索表达式前<code>\v</code>使用very magic 功能，正则表达式任何元字符都不用加<code>\</code>，如：<code>/\v(a.c){3}$</code>  就是查找行尾三个字符是<strong>a{char}c</strong>的表表达式(如abc,acc,aec)。</p>
<p>强制关闭magic:<br>如果已经<code>set magic</code>，要在搜索表达式里强制不用magic，就在前面加<code>\V</code>,比如已经开启了<code>set magic</code>，使用 <code>/\V.*</code>搜索的是<code>.*</code>字符串。</p>
<p>单词界定：<br>在very magic 模式下，使用<code>&lt;word&gt;</code>可以以单词为界匹配字符，而不会匹配到其他内容。比如目前有个文本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abc aa</span><br><span class="line">abcdedf</span><br><span class="line">1234</span><br><span class="line">123abc</span><br></pre></td></tr></table></figure></p>
<p>用 <code>/\v&lt;abc&gt;</code>搜索时，只有第一行 <code>abc</code> 匹配，<code>123abc</code>不会匹配。</p>
<p>模式匹配边界：<br>一个匹配的边界通常对应于一个模式的起始与结尾。但我们可以使用元字符 <code>\zs</code> 与 <code>\ze</code>对匹配进行裁剪，使其成为这个完整模式的一个子集（参见 :h /\zs ） 。元 字符 <code>\zs</code>标志着一个匹配的起始，而元字符<code>\ze</code>则用来界定匹配的结束。将二者相结合，我们可以定义一个特殊的模式，它们可以让我们定义一个模式匹配一个较大的文本范围，然后再收窄匹配范围。与单词定界符类似，<code>\zs</code>与<code>\ze</code> 均为零宽度元字符。 </p>
<p>vim中模式的特殊元字符 ，<code>\zs</code> 与<code>\ze</code>关键字示例：<br><img src="http://ww1.sinaimg.cn/large/720db05fgy1fxbbtpdsb4j20ew0383yi.jpg" alt></p>
<p>必须转义的情况：</p>
<ol>
<li>正向查找时，<code>/</code>必须转义。</li>
<li>反向查找时，<code>?</code>必须转义。</li>
<li>每次都要转义<code>\</code>。</li>
</ol>
<p>查找&amp;替换<br>显示当前查找关键词个数： <code>:%s///gn</code></p>
<p>将光标定位到匹配结果词尾：<code>/lang/e</code> </p>
<p>重用上次查找的模式<br><code>:%s/\va.c/123/g</code><br>等价于以下两个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\v.c</span><br><span class="line">%s//123/g</span><br></pre></td></tr></table></figure></p>
<h2 id="global-命令"><a href="#global-命令" class="headerlink" title="global 命令"></a>global 命令</h2><p>:global命令的广义形式如下所示：<br><code>:g/{pattern}/[range][cmd]</code><br><code>:g/{re}/{cmd}</code>  在匹配的行上执行命令，如 <code>:g/re/d</code>  ，删除包含re字符的行<br><code>:v/{re}/{cmd}</code>  在非匹配的行上执行命令  如 <code>:v/re/d</code>  ，删除<strong>不包含</strong>re字符的行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2018/10/21/Java中的CAS与ABA问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/21/Java中的CAS与ABA问题/" class="post-title-link" itemprop="url">Java中的CAS与ABA问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-21 20:01:00" itemprop="dateCreated datePublished" datetime="2018-10-21T20:01:00+08:00">2018-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天面试别人的时候，提到了CAS，本来想要引导他说出CAS潜在的ABA问题，发现自己也没发简单的向他解释清楚,需要好好梳理下。</p>
<h2 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h2><p>维基百科的解释是：</p>
<blockquote>
<p>In computer science, compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization. It compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value. This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail. The result of the operation must indicate whether it performed the substitution; this can be done either with a simple boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).</p>
</blockquote>
<p>CAS(compare and swap)，简单地说就是一种在多线程的情况下，让每个线程修改某个数据是一种原子操作。要实现CAS，有几个关键的值：</p>
<ol>
<li>要修改的变量内存中的值V</li>
<li>更新变量前事先记录的期望值E，取值来自V</li>
<li>将要更新的值A</li>
</ol>
<p>一个典型的CAS更新操作如下：</p>
<ol>
<li>读取内存中的值V，赋值给E</li>
<li>更新变量前，比较内存值V与E</li>
<li>如果V==E,将V更新成A</li>
<li>如果V!=E，重复步骤1</li>
</ol>
<p>如此循环，直到步骤3更新操作完成，写成伪代码就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e=v.getVal();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e==getVal())&#123;</span><br><span class="line">            v.setVal(a);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>CAS在JDK中被广泛应用，比如java.util.concurrent包下面的Lock、AtomicInteger相关的类都有用到。<br>例如<code>a++;</code>这种操作在Java里面并不是原子操作（包含了值的累加和赋值两个动作），所以并发情况下竞争操作某一个变量，需要用AtomicXXX几个类。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>AtomicInteger 实现类似<code>a++</code>操作，使用的是它的<code>incrementAndGet</code> 方法，源码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 此处的 compareAndSet 由usafe对象提供硬件级别的原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock中对于竞争变量的CAS，也是类似的操作。</p>
<h2 id="什么是ABA问题"><a href="#什么是ABA问题" class="headerlink" title="什么是ABA问题"></a>什么是ABA问题</h2><p>简单地说就是，多个线程同时使用CAS更新数据时：</p>
<ol>
<li>线程1要将数据从A变成B时（此时线程1的期待值E==’A’）</li>
<li>其他线程已经抢先更新了变量，把变量从A变成其他值，再变回A（如A-&gt;C-&gt;A）。</li>
<li>当线程1用CAS机制准备更新变量时，发现E==A，所以继续更新变量。</li>
</ol>
<h3 id="这样有什么问题？"><a href="#这样有什么问题？" class="headerlink" title="这样有什么问题？"></a>这样有什么问题？</h3><p>虽然变量最终结果是对的，但是线程1更新变量前，变量已经经历了一系列变化才回到原值。对于某些场景，忽略变化会继续进行更新操作，会带来错误的结果。<br>比如：</p>
<h4 id="银行账户扣费问题"><a href="#银行账户扣费问题" class="headerlink" title="银行账户扣费问题"></a>银行账户扣费问题</h4><p>某个银行账户扣款操作，由于系统故障，产生了2个线程（T1,T2）对同一账户进行扣款，正常防重逻辑应该是一个执行成功，另一个失败，但是如果使用上面的CAS操作，就是：</p>
<ol>
<li>账户里有100元，需要扣款50元</li>
<li>T1先完成操作，扣款50元，将账户值V改为50</li>
<li>T2准备扣款，当时期待值E==100</li>
<li>此时有其他转账操作先于T2对V进行累加，比如转入50元，此时V又变成100</li>
<li>T2进行CAS的更新操作，发现E\==V\==100,执行更新操作，<strong>又扣款50</strong></li>
</ol>
<h4 id="堆栈操作问题"><a href="#堆栈操作问题" class="headerlink" title="堆栈操作问题"></a>堆栈操作问题</h4><p>如果CAS中的操作，变量值V是栈顶指针，也会有同样的问题：</p>
<ol>
<li>某个堆栈内容是：A-B-C,栈顶为A</li>
<li>线程1更新前，得到期望值E==A</li>
<li>其他线程对栈进行进行pop,push操作，pop A B,push D A,此时栈的内容为 A-D-C</li>
<li>此时栈顶还是A，但是内容已经改变，线程1要更新的堆栈，已经不是第2步拿到期望值E时，自己要操作的那个堆栈了</li>
</ol>
<h3 id="如何规避"><a href="#如何规避" class="headerlink" title="如何规避"></a>如何规避</h3><p>思路也很简单，就是对得到的期望值E和变量值V，增加一个版本号（比如时间戳），对于不同时期操作产生的同一个值的V，版本号是不同的，比较E与V时，需要同时比较版本号。比如juc包的<code>AtomicStampedReference</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;  <span class="comment">//维护对象引用</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;  <span class="comment">//用于标志版本</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * expectedReference ：更新之前的原始值</span></span><br><span class="line"><span class="comment">      * newReference : 将要更新的新值</span></span><br><span class="line"><span class="comment">      * expectedStamp : 期待更新的标志版本</span></span><br><span class="line"><span class="comment">      * newStamp : 将要更新的标志版本</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair; <span class="comment">//获取当前pair</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp; <span class="comment">//原始值等于当前pair的值引用，说明值未变化</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp; <span class="comment">// 原始标记版本等于当前pair的标记版本，说明标记未变化</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) || <span class="comment">// 将要更新的值和标记都没有变化</span></span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">// cas 更新pair</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>CAS 是一种自旋锁，由一个死循环+compareAndSet 实现。</li>
<li>CAS 存在ABA隐患，对于需要关注竞争变量变化过程（不仅仅是变量的值）的场景，ABA问题必须关注。</li>
<li>解决ABA问题，需要在CAS的compare过程中，增加对期望值E和当前值V版本号的判断。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2018/10/05/2018-10西安游/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/2018-10西安游/" class="post-title-link" itemprop="url">黄金周西安游</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 19:20:00" itemprop="dateCreated datePublished" datetime="2018-10-05T19:20:00+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>9月底突发奇想地想国庆和老婆来西安玩一次，于是就匆匆忙忙订了机票和住宿，提前请了2天假29号飞到了西安。28晚上自己刚从北京出差回来，简直马不停蹄。从29号启程到4号回家，我们看了长恨歌演出，逛了西安城区、华山、陕西历史博物馆、华清池、兵马俑、西安城墙。一路上吃吃喝喝，除了在兵马俑见识了千分之一的中国人口以外，其他时候体验不算太差。整座西安城给人一种浓厚的历史氛围和民族融合带来的活力，让沿海长大的我倍感新奇。</p>
<h2 id="衣"><a href="#衣" class="headerlink" title="衣"></a>衣</h2><p>9月底10月初的西安，让我一个南方人感受到了秋天。一天气温十几度到二十几度，早晚偏冷，白天晒着太阳也不会满头大汗，真正的秋高气爽。所以每天出门我总是穿着一件薄长袖和夹克外套，热了就把外套脱下别在腰上。值得一提的是，西安城内经常能见到穿着汉服的姑娘小伙，也许是这座城市的道路和建筑本身古色古香，不想在其他地方，走在街上看着他们，竟然不觉得突兀，反而别有一番风味，有种“这果然是长安啊”的感叹。</p>
<h2 id="食"><a href="#食" class="headerlink" title="食"></a>食</h2><p>西安的吃，只要吃得惯的话，简直不要太棒。<br>6天时间内，我们逛遍了回民街永兴坊，这里的吃的价格也不算便宜，但是分量够大，随便一份面食都是一大碗，我跟老婆为了多尝几口，总是要两人吃一份。第一天老婆同学请吃羊肉泡馍，见识了如何自助徒手撕膜，撕了半个小时手都麻了，煮上羊肉粉丝汤，满满的一大海碗，吃完都快扶着墙出。路边烤羊肉串一串10块，羊肉又大又肥。面馆里的水盆羊肉、biangbiang面、油泼面……每一个都在让我跟米饭说再见。肉夹馍每家卖的都不大一样，什么都能夹，简直西安汉堡。还有永兴坊的子长煎饼，长得跟广东肠粉一样，吃一份得排半小时队。路边随处可见的石榴汁，小镜糕，大甄糕，酸梅汤，花椒酸奶（真加花椒。。），油茶（这个怂了喝不惯），凉粉，酱牛肉，卤羊蹄，羊杂汤……几天下来，自己的味蕾仿佛打开了一个新世界。</p>
<h2 id="住"><a href="#住" class="headerlink" title="住"></a>住</h2><p>由于我们住的酒店离西安城中心挺近的，我们一有空就往钟楼附近跑。钟楼算是西安城区的中心，再加上周围14公里的西安城墙，整个城内古色古香，建筑风格很有特色，满眼望去都是中国传统的中间高两边低的那种屋顶，这种我以前只在电视剧和故宫里看到。路也很宽，在市内骑自行车很舒服，道路横平竖直，房子坐落得也很规整，整个城市颜色跟中国大多数内陆城市一样，整体偏灰色调。虽然国庆路上人多，地上也不见什么垃圾。不知道是不是来的这几天天气好，空气虽然干燥，但是空气还算清新，蓝天白云的天空配合飒爽的秋意给人感觉很好。</p>
<h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><p>这几天出门一般都是打的外加摩拜，出租车司机师傅跟大多数北方司机一样，喜欢唠嗑，平易近人。西安城区的街道方方正正，看好地图的话，骑车走路都不容易迷路（当然回民街还是要多走几次才懂）。比较痛苦的是去周边景区的大巴车，去华山、兵马俑、华清池我们都报的是一日团，一大早就要坐车出发，路上快则两个小时，堵车就要三四个小时，体验不是很好，特别是从兵马俑回来的时候，我们晚上6点返程，回来已经9点半了。</p>
<h2 id="玩"><a href="#玩" class="headerlink" title="玩"></a>玩</h2><p>这次行程也算比较紧，第一晚我们去华清池看了长恨歌演出，华山、陕西历史博物馆、兵马俑华清池我们各花了一天时间，最后一天逛了西安城墙，然后在几个晚上陆续逛了钟楼附近和回民街永兴坊，大雁塔之类的景点就没再去了。</p>
<p>长恨歌演出门票260多块钱，需要坐车到华清池景区看（后来想想应该在参观兵马俑华清宫的那天晚上来看比较节省时间）。第一次看这种现场的真人歌舞剧表演，比较新鲜，有种春晚现场的感觉，大体上就是用现代声光电技术演了一出杨贵妃唐玄宗的爱情故事，后面还有鹊桥相会啥的（能把一个公公儿媳扒灰的故事写的如此美好也是囧。。）。可惜我艺术功底不够深刻，只能跟周围的大叔大妈看个新鲜。</p>
<p>第二天一大早坐大巴来登华山，两人比较怂，选择了缆车路线，西峰上北峰下，5个小时爬了华山西峰南峰。一整块花岗岩形成的华山，挺拔陡峭，地势险峻，山上很多台阶不到半个脚宽。站在华山上，俯瞰山下，真的会让人感叹祖国大好河山，雄伟瑰丽。可惜最近上班忽略了身体锻炼，西峰爬了不到一半就气喘吁吁，追不上老婆的步伐。看来回去还是要好好锻炼，有生之年要从山底下上一次，来东峰看日出。</p>
<p>第三天鉴于前一天爬华山太累，就选择了市内的陕西历史博物馆，还好提前订了30块钱的大唐珍宝馆门票，免去了排长队进馆的痛苦。陕博不愧为中国博物馆的Top，文物之多，时间跨度之长令人叹为观止。</p>
<p>第四天我们又跟了一日团参观了华清池和兵马俑，这一天算是体验最差的一天。华清池参观什么呢，就是看看以前杨贵妃杨玄宗洗澡的澡堂子，还有西安事变老蒋被抓之前的故居，都是历史遗迹，想要知道以前的情景，只能对着景观配合导游解说发挥想象力了。下午的兵马俑参观让我体验了什么是“世界第一大坑”。据说当天下午兵马俑的客流量达到了15万，从进博物馆大门到走到展馆门口，浩浩荡荡都是人头，排队的时候前胸贴后背，整个人被后面推着走。要进一号坑之前更是痛苦，博物馆方管理太混乱，三队人马三个方向进一个门，其中不乏插队的低素质游客，大家互不相让，差点爆发肢体冲突。进坑之后人山人海，根本看不到前面，人在队伍中，不由自主地被后面人推着走，还没仔细看完兵马俑的细节，就被推着到出口了。</p>
<p>第五天西安城墙游算是最满意的一天，跟老婆吃完一顿早午饭，慢慢悠悠地买上一张上城墙的票，租上一辆双人自行车，开始休闲游。中午到下午这段时间城墙上人不多，西安城墙虽然不是水泥路，但是一路上没有什么坡度，也足够宽敞，3个小时车程下来，轻轻松松绕城墙骑行了一圈半，两边都是充满古城特色的房子和风景，伴着凉爽的秋意，一扫前几天旅行的疲惫。</p>
<h2 id="写在旅行结束后"><a href="#写在旅行结束后" class="headerlink" title="写在旅行结束后"></a>写在旅行结束后</h2><p>最后坐飞机回来前，老婆问我，西安比起以前去过的重庆和成都怎么样？我觉得除了兵马俑那天的大坑以外，西安还是让我非常喜欢的。较慢的生活节奏，好吃的各种美食，浓厚的历史底蕴，人们美好的精神面貌。甚至我都觉得，下半辈子我们应该好好锻炼身体，攒钱来西安置业养老（笑）。人生不应该只有生活工作的那三点一线，应该多一点不一样的经历。相信有生之年，我还会再来几次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2017/06/01/ThinkPad-x240-使用Manjaro小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/01/ThinkPad-x240-使用Manjaro小记/" class="post-title-link" itemprop="url">ThinkPad-x240-使用Manjaro小记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-01 19:01:25" itemprop="dateCreated datePublished" datetime="2017-06-01T19:01:25+08:00">2017-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近淘了一部二手x240,换了SSD和高分屏，装上manjaro 17 作为开发备用机，期间遇到了许多坑，在这边同一记录。</p>
<p>原先使用了KDE桌面，后面发现性能还是跟不上，换成了更轻量级的xfce，All is well~</p>
<h2 id="制作U盘启动"><a href="#制作U盘启动" class="headerlink" title="制作U盘启动"></a>制作U盘启动</h2><p>下载 rufus 制作u盘启动</p>
<h2 id="使用U盘安装，启动后显示“failed-to-load-ldlinux-c32”"><a href="#使用U盘安装，启动后显示“failed-to-load-ldlinux-c32”" class="headerlink" title="使用U盘安装，启动后显示“failed to load ldlinux.c32”"></a>使用U盘安装，启动后显示“failed to load ldlinux.c32”</h2><p>传统BIOS与UEFI启动的问题，在BIOS的启动选项里，将启动方式改为<strong>UEFI优先即可</strong>。</p>
<h2 id="更换和添加源"><a href="#更换和添加源" class="headerlink" title="更换和添加源"></a>更换和添加源</h2><pre><code>sudo nano /etc/pacman.d/mirrors/China
</code></pre><p>manjaro 17 中 China 文件已经内置了中国的源，建议把清华的源镜像放在第一位</p>
<pre><code>sudo nano /etc/pacman.d/mirrorlist
</code></pre><p>建议把清华的源镜像放在第一位，更新列表和系统的时候速度会快</p>
<pre><code>sudo nano /etc/pacman-mirrors.conf
</code></pre><p>修改 <code>OnlyCountry = China</code> （注意把前面的注释 # 删掉）</p>
<p>保存退出 ### 添加archlinuxcn</p>
<pre><code>sudo nano /etc/pacman.conf
</code></pre><p>添加</p>
<pre><code>[archlinuxcn]
SigLevel = Optional TrustedOnly
Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 
#Server = https://mirrors.6.tuna.tsinghua.edu.cn/archlinuxcn/$arch
# only IPv6#Server = https://mirrors.4.tuna.tsinghua.edu.cn/archlinuxcn/$arch
# only IPv4#HTTP is also supported
</code></pre><p><code>sudo pacman -Syy</code> 更新一下源列表，此处若出现错误，请按照终端提示，删除一个文件 （本机是类似于/var/lib*的一个db文件）</p>
<pre><code># 更新出现以下错误，只要把提示的文件删除即可
libglvnd: 文件系统中已存在 /usr/lib/libEGL.so.1  
libglvnd: 文件系统中已存在 /usr/lib/libEGL.so.1.0.0  
libglvnd: 文件系统中已存在 /usr/lib/libGL.so  
libglvnd: 文件系统中已存在 /usr/lib/libGL.so.1  
libglvnd: 文件系统中已存在 /usr/lib/libGLESv1_CM.so  
libglvnd: 文件系统中已存在 /usr/lib/libGLESv1_CM.so.1  
libglvnd: 文件系统中已存在 /usr/lib/libGLESv2.so  
libglvnd: 文件系统中已存在 /usr/lib/libGLESv2.so.2  
libglvnd: 文件系统中已存在 /usr/lib/libGLESv2.so.2.0.0  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libEGL.so  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libEGL.so.1  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libEGL.so.1.0.0  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGL.so  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGL.so.1  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGLESv1_CM.so  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGLESv1_CM.so.1  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGLESv2.so  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGLESv2.so.2  
lib32-libglvnd: 文件系统中已存在 /usr/lib32/libGLESv2.so.2.0.0
</code></pre><p>重新执行 <code>sudo pacman -Syy</code> 就没有问题了</p>
<p><code></code>sudo pacman -S archlinuxcn-keyring` 此步很关键，是安装archlinuxcn的GPG keys 滚动升级一下系统和软件(不建议频繁滚动升级，稳定为主)</p>
<pre><code>sudo pacman -Syyu
</code></pre><p>开始更新系统了</p>
<h2 id="安装-vi"><a href="#安装-vi" class="headerlink" title="安装 vi"></a>安装 vi</h2><pre><code>pacman -Syy vi
</code></pre><h2 id="安装-aur客户端"><a href="#安装-aur客户端" class="headerlink" title="安装 aur客户端"></a>安装 aur客户端</h2><p><a href="https://www.linuxdashen.com/arch-linux%E4%BD%BF%E7%94%A8yaourt%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E8%BD%BB%E6%9D%BE%E5%AE%89%E8%A3%85aur%E8%BD%AF%E4%BB%B6%E5%8C%85" target="_blank" rel="noopener">yaourt安装与使用</a> 用yaourt装东西，每次sudo yaourt -S xxx 最后出现</p>
<pre><code>错误： 不能使用 root 用户运行 makepkg， 
因为可能会系统造成灾难性的损坏。 
无法读取 PKGBUILD
</code></pre><p>原因： 不能用 sudo 运行 yaourt ,换句话说必须在普通用户下运行 yaourt yaourt 停止维护了，可以改用yay <code>sudo pacman -Syy yay</code></p>
<h2 id="让终端走代理"><a href="#让终端走代理" class="headerlink" title="让终端走代理"></a>让终端走代理</h2><p>安装并运行 privoxy 或者 polipo, 把本地ss代理转换成http代理，然后把终端代理设置到http代理上：</p>
<pre><code>export https_proxy=http://localhost:8123
export http_proxy=http://localhost:8123
</code></pre><p>终端打开的程序就会走代理了。</p>
<h2 id="安装-搜狗输入法"><a href="#安装-搜狗输入法" class="headerlink" title="安装 搜狗输入法"></a>安装 搜狗输入法</h2><pre><code>sudo pacman -S fcitx-sogoupinyin
sudo pacman -S fcitx-im # 全部安装
sudo pacman -S fcitx-configtool # 图形化配置工具
</code></pre><p>之后就是还需要更改 ~/.xprofile</p>
<pre><code>export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=&quot;@im=fcitx&quot;
</code></pre><p>最后在命令行输入fcitx就可以使用了 </p>
<h3 id="安装日语输入法"><a href="#安装日语输入法" class="headerlink" title="安装日语输入法"></a>安装日语输入法</h3><pre><code>yay -Syy fcitx-anthy
</code></pre><h2 id="dock-软件"><a href="#dock-软件" class="headerlink" title="dock 软件"></a>dock 软件</h2><p><code>aur docky</code></p>
<h2 id="高分屏像素缩放"><a href="#高分屏像素缩放" class="headerlink" title="高分屏像素缩放"></a>高分屏像素缩放</h2><p>系统设置-字体-固定字体dpi 110, 不使用缩放，很多软件在开启缩放后会模糊或其他问题。固定字体的dpi就可以达到缩放效果了。</p>
<h2 id="合上盖子，按电源键挂起没有效果"><a href="#合上盖子，按电源键挂起没有效果" class="headerlink" title="合上盖子，按电源键挂起没有效果"></a>合上盖子，按电源键挂起没有效果</h2><p>经过测试，发现按电源键没产生 acpi 事件，因此不能触发电源管理，此暂不能解决。曲线救国：用fn+f9作为快捷键挂起计算机。</p>
<h2 id="指纹模块"><a href="#指纹模块" class="headerlink" title="指纹模块"></a>指纹模块</h2><p>参考： <a href="https://wiki.archlinux.org/index.php/Fingerprint-gui" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Fingerprint-gui</a> 配置完成后su和sudo要求输入密码时，就可以用刷指纹了。 ### 运行fingerprint-gui时出现 could not open fingerprint device permission problem 是因为普通用户没有指纹设备的读写权限。 lsusb 找到指纹模块的 Bus号和Device号，比如：</p>
<pre><code>Bus 002 Device 002: ID 138a:0017 Validity Sensors, Inc. Fingerprint Reader
</code></pre><p>然后赋予<code>/dev/bus/usb/xxx/yyy</code> 777权限 xxx表示Bus号，yyy表示Device号，上面的例子就是 <code>/dev/bus/usb/002/002</code> <a href="http://home.ullrich-online.cc/fingerprint/Forum/topic.php?TopicId=20" target="_blank" rel="noopener">http://home.ullrich-online.cc/fingerprint/Forum/topic.php?TopicId=20</a></p>
<h2 id="KDE-登录界面无法使用指纹识别登录"><a href="#KDE-登录界面无法使用指纹识别登录" class="headerlink" title="KDE 登录界面无法使用指纹识别登录"></a>KDE 登录界面无法使用指纹识别登录</h2><p>fingerprint与kde的kdm不兼容，暂时无解。</p>
<h2 id="IDEA-某些菜单乱码"><a href="#IDEA-某些菜单乱码" class="headerlink" title="IDEA 某些菜单乱码"></a>IDEA 某些菜单乱码</h2><p><a href="http://www.cnblogs.com/lemonbar/p/3924305.html" target="_blank" rel="noopener">http://www.cnblogs.com/lemonbar/p/3924305.html</a></p>
<h2 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h2><p><strong>触摸板优化只在 KDE 环境下配置成功过，xfce下不行。</strong></p>
<h3 id="鼠标点击模拟”-下面的选项是无效"><a href="#鼠标点击模拟”-下面的选项是无效" class="headerlink" title="鼠标点击模拟” 下面的选项是无效"></a>鼠标点击模拟” 下面的选项是无效</h3><p>触摸板设置中，“鼠标点击模拟” 下面的选项是灰色的，导致触摸板双指点击作为右键的功能不能用。 </p>
<p>解决方案 ： pacman 安装驱动 重启即可 触摸板驱动：xf86-input-libinput<br>官方从17年1月开始换成 libinput驱动，xf86-input-synaptics进入低维护状态，尽量不用</p>
<p>具体参考  <a href="https://wiki.archlinux.org/index.php/Lenovo_ThinkPad_X240#Touchpad" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/Lenovo_ThinkPad_X240#Touchpad touchpad</a>  一节</p>
<p>触摸板鼠标手势 安装 <a href="https://github.com/bulletmark/libinput-gestures" target="_blank" rel="noopener">libinput-gestures</a><br>参考 <a href="http://www.cnblogs.com/xiaozhang9/p/6157934.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaozhang9/p/6157934.html</a></p>
<p>自定义配置文件（x240 最多支持3点触控） <code>~/.config/libinput-gestures.conf</code></p>
<pre><code>gesture swipe left 4 xdotool key super+Left # 4指左划: 切换到左侧工作区 
gesture swipe right 4 xdotool key super+Right # 4指右划: 切换到右侧工作区 

gesture swipe left 3 xdotool key alt+Left # 3指左划: 网页后退 
gesture swipe right 3 xdotool key alt+Right # 3指右划: 网页前进 
gesture swipe up 3 xdotool key super+w  # 3指上划: 显示当前桌面所有窗口 
gesture swipe down 3 xdotool key super+d # 3指下划: 显示桌面 

gesture pinch in 2 xdotool key ctrl+minus # 2指捏: 缩小 
gesture pinch out 2 xdotool key ctrl+plus # 2指张: 放大
</code></pre><p>保存配置文件 然后启动 <code>libinput-gestures-setup start</code> 也可以重启 <code>libinput-gestures-setup restart</code> 加入开机启动 <code>libinput-gestures-setup autostart</code></p>
<h2 id="取消自动锁屏（KDE）"><a href="#取消自动锁屏（KDE）" class="headerlink" title="取消自动锁屏（KDE）"></a>取消自动锁屏（KDE）</h2><p>系统设置–桌面行为–锁屏 中设置</p>
<h2 id="没有ifconfig命令"><a href="#没有ifconfig命令" class="headerlink" title="没有ifconfig命令"></a>没有ifconfig命令</h2><p>安装net-tool</p>
<pre><code>pacman -S net-tools dnsutils inetutils iproute2
</code></pre><p>##共享鼠标键盘软件 synergy 下载地址 <a href="http://www.afzaalace.com/synergy-stable-builds/" target="_blank" rel="noopener">http://www.afzaalace.com/synergy-stable-builds/</a><br>arch 可以直接用pacman下载</p>
<p>Synergy分为服务端和客户端，用户使用鼠标键盘的那一台机子是服务端，其他的是客户端 Arch下的服务端配置 <code>/etc/synergy.conf</code></p>
<pre><code># screens 指的是操作的电脑的名字， 
section: screens  
       caixx-pc:  
       Eternity-Home:  
end  
# 配置各电脑之间的相对位置 
section: links  
       caixx-pc:  
               left = Eternity-Home  

       Eternity-Home:  
               right  = caixx-pc  

end  
# 电脑别名 
section: aliases  
       caixx-pc:  
               192.168.1.103  
       Eternity-Home:  
               192.168.1.105  
end
</code></pre><p>配置完后运行服务端 <code>synergys -f</code><br>运行客户端 <code>synergyc -f 服务端ip地址</code></p>
<h2 id="xfce-桌面相关"><a href="#xfce-桌面相关" class="headerlink" title="xfce 桌面相关"></a>xfce 桌面相关</h2><p>主题： aur paper-gtk-theme-git<br>aur paper-icon-theme-git aur paper-icon-theme</p>
<p>ctrl键交换 修改 ~/.profile 增加 /usr/bin/setxkbmap -option “ctrl:swapcaps”</p>
<p>一些快捷键命令： </p>
<p>睡眠 xfce4-session-logout –suspend</p>
<p>休眠 xfce4-session-logout –hibernate<br>弹出开始菜单 xfce4-popup-whiskermenu</p>
<p>锁屏 xflock4 </p>
<p>哪里设置快捷键？ 全局快捷键： setting –&gt; keyboard –&gt; Application shortcuts 窗口相关快捷键：setting –&gt; windows manager</p>
<p>打开docky有，屏幕中间有一条线： image.png-276.2kB 设置-窗口管理器微调-合成器-去掉勾选“在dock窗口下显示阴影”</p>
<p>锁定屏幕后一段时间再用电脑，出现黑屏，只看到鼠标： 关闭屏保试试: 在设置种的 电源管理器 里关闭所有会关闭屏幕的选项 aur light-locker-settings 在设置里关闭 light-locker</p>
<p>滚动背景窗口时，不改变窗口焦点</p>
<p>Settings —&gt; Window Manager Tweaks —&gt; Accessibility 取消‘raise windows when any mouse button is pressed’ 选项</p>
<p><img src="Untitled-4b6c7e42-d2be-4469-a01f-03cc6f642bc5.png" alt></p>
<h2 id="Arch-上维护的常用程序列表-wiki"><a href="#Arch-上维护的常用程序列表-wiki" class="headerlink" title="Arch 上维护的常用程序列表 wiki"></a>Arch 上维护的常用程序列表 wiki</h2><p>常用的程序都可以在上面找到： <a href="https://wiki.archlinux.org/index.php/List_of_applications_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/List_of_applications_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a>)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2016/11/08/第N次开博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/08/第N次开博客/" class="post-title-link" itemprop="url">第N次开博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-11-08 18:35:18" itemprop="dateCreated datePublished" datetime="2016-11-08T18:35:18+08:00">2016-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>也不知道这是第几次搭博客了，新浪博客、QQ空间、百度空间、CSDN、ITEYE、OSChina、自建博客……折腾博客的经历几乎跟自己的网龄一样长。写博文这件事，也没有一直坚持下来。所以，为什么这次又开了一个博客？自己总结了以下几点：</p>
<p>我的工作生活，需要一个宣泄的地方。<br>想要再锻炼一下自己写技术博客的能力。<br>很不习惯熟人看到我写的东西，不会再暴露任何个人信息了。<br>年纪一大，不想再折腾，免费博客服务是我的首选。<br>So，这次直接选了hexo，再尝试一次，看看自己能做到哪一步吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tachikoma</p>
  <div class="site-description" itemprop="description">Less is more</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tachikoma</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
