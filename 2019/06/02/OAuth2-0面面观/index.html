<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tachikomachann.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="只要是接触过各种开放平台的开发者，对于OAuth概念肯定不陌生。但是由于OAuth流程比较复杂，对于刚接触的人来说，容易云里雾里。我之前工作上接触OAuth比较多，本文以OAuth2.0的RFC文档为基础，结合自己以前一些工作上的经验，系统地梳理一下OAuth2.0规范。 What is OAuth关于OAuth的定义，维基百科是这么说的：  OAuth is an open standard">
<meta name="keywords" content="web">
<meta property="og:type" content="article">
<meta property="og:title" content="OAuth2.0面面观">
<meta property="og:url" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/index.html">
<meta property="og:site_name" content="タチコマの部屋">
<meta property="og:description" content="只要是接触过各种开放平台的开发者，对于OAuth概念肯定不陌生。但是由于OAuth流程比较复杂，对于刚接触的人来说，容易云里雾里。我之前工作上接触OAuth比较多，本文以OAuth2.0的RFC文档为基础，结合自己以前一些工作上的经验，系统地梳理一下OAuth2.0规范。 What is OAuth关于OAuth的定义，维基百科是这么说的：  OAuth is an open standard">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-fd497460-61c4-4965-8a17-b8713a4c9372.png">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-e8759fb4-4901-449a-aea8-9abb58109b82.png">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-3328dbda-4800-4e0a-8e69-9aeccec4061d.png">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-2a5aa9d0-2e52-43d2-9a74-ef24c45f72ac.png">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-4dc8306d-39bc-4d5d-937c-2e4ae4645294.png">
<meta property="og:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-c5f08367-0a87-4b30-a497-d1194581e665.png">
<meta property="og:updated_time" content="2020-11-28T09:20:52.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OAuth2.0面面观">
<meta name="twitter:description" content="只要是接触过各种开放平台的开发者，对于OAuth概念肯定不陌生。但是由于OAuth流程比较复杂，对于刚接触的人来说，容易云里雾里。我之前工作上接触OAuth比较多，本文以OAuth2.0的RFC文档为基础，结合自己以前一些工作上的经验，系统地梳理一下OAuth2.0规范。 What is OAuth关于OAuth的定义，维基百科是这么说的：  OAuth is an open standard">
<meta name="twitter:image" content="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/Untitled-fd497460-61c4-4965-8a17-b8713a4c9372.png">

<link rel="canonical" href="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>OAuth2.0面面观 | タチコマの部屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">タチコマの部屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://tachikomachann.github.io/2019/06/02/OAuth2-0面面观/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tachikoma">
      <meta itemprop="description" content="Less is more">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="タチコマの部屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OAuth2.0面面观
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-02 20:30:22" itemprop="dateCreated datePublished" datetime="2019-06-02T20:30:22+08:00">2019-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-28 17:20:52" itemprop="dateModified" datetime="2020-11-28T17:20:52+08:00">2020-11-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="Untitled-fd497460-61c4-4965-8a17-b8713a4c9372.png" alt></p>
<p>只要是接触过各种开放平台的开发者，对于OAuth概念肯定不陌生。但是由于OAuth流程比较复杂，对于刚接触的人来说，容易云里雾里。我之前工作上接触OAuth比较多，本文以OAuth2.0的RFC文档为基础，结合自己以前一些工作上的经验，系统地梳理一下OAuth2.0规范。</p>
<h2 id="What-is-OAuth"><a href="#What-is-OAuth" class="headerlink" title="What is OAuth"></a>What is OAuth</h2><p>关于OAuth的定义，维基百科是这么说的：</p>
<blockquote>
<p>OAuth is an open standard for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords. This mechanism is used by companies such as Amazon, Google, Facebook, Microsoft and Twitter to permit the users to share information about their accounts with third party applications or websites.</p>
</blockquote>
<p>O == Open, Auth == Authorization（授权）, not Authentication（认证）.</p>
<p>首先要明确的是，OAuth是一种授权协议，而非认证协议。通过它，用户可以授权第三方应用访问自己保存在资源服务器器上的资源。当然，如果这些资源是账号信息，第三方服务器也可以基于OAuth实现类似SSO的单点登录，完成登录认证。</p>
<h2 id="OAuth历史"><a href="#OAuth历史" class="headerlink" title="OAuth历史"></a>OAuth历史</h2><p><img src="Untitled-e8759fb4-4901-449a-aea8-9abb58109b82.png" alt></p>
<p>上面这张图基本涵盖了OAuth诞生的相关历史进程。</p>
<p>在2006年，Twitter在开发他们自己的OpenID实现，而当时Ma.gnolia网站需要一个使用OpenID授权访问他们网站资源的方案，双方会面讨论后发现当时并没有一个统一的标准API实现这件事。</p>
<p>上面功能的实现者们于2007年成立了OAuth讨论组，撰写并公布了最早的开放授权（OAuth）草案。这个草案后来得到了Google的关注，最终也一起参与了规范的制定。</p>
<p>在2007年10月，OAuth1.0草案公布。</p>
<p>在2008年11月的IETF第73次会议上，OAuth得到广泛支持，IETF正式为它成立了一个工作组。</p>
<p>2010年，编号为RFC-5849的OAuth1.0 RFC文档发表。</p>
<p>在2012年，OAuth2.0 的RFC-6749, 和Bearer Token 的 RFC-6750相继发表。大多数互联网应用都以此作为授权标准。需要注意的是OAuth2.0与OAuth1.0并不兼容。</p>
<p>虽然IETF的RFC意为征求意见稿(Request for Comment)，但是目前它已经是开放授权的事实标准。</p>
<p>本文后续的一些内容，提炼自IETF的RFC文档，并结合我自己工作中的一些经验总结。</p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>了解OAuth2.0之前，我们先熟悉几个概念。</p>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p><img src="Untitled-3328dbda-4800-4e0a-8e69-9aeccec4061d.png" alt></p>
<p>OAuth2.0 把整个流程中的参与者分为4种角色：</p>
<ol>
<li>Resource Owner：资源拥有者，通常是我们网站/应用的用户。</li>
<li>Client secret：与Client id 配对的密钥，格式各家实现不用，保证安全性即可。在进行OAuth授权流程时，Client必须提供Client id与 Client secret。如果Client secret发生泄露，出于安全考虑，Authorization Server一般允许注册方重新生成secret.</li>
<li>Client：客户端，一般指第三方应用程序，即资源使用方。比如豆瓣注册时，需要用户的微信头像做豆瓣头像，此时豆瓣就是Client。</li>
<li>Authorization Server：授权服务器，对Client进行授权时验证客户端，用户合法性的节点。Resource Server 和 Authorization Server可能是同一个（比如资源是账号数据时）也可能不同。</li>
</ol>
<h3 id="几个术语"><a href="#几个术语" class="headerlink" title="几个术语"></a>几个术语</h3><p>首先，Client 想要得到Authorization Server 的授权，需要先注册。比如各种开放平台，需要先由开发者提供网站地址，应用名称，默认重定向地址等信息，才能为其颁发合法的Client id 和 Client Secret 进行OAuth授权。</p>
<ol>
<li>Client id：是 Client 在Authorization Server注册的标志，格式各家实现不同，但是需要全局唯一。一般注册后不会改变，也有实现方喜欢叫App id。</li>
<li>Client secret：与Client id 配对的密钥，格式各家实现不用，保证完全性即可。在进行OAuth授权流程时，Client必须提供Client id与 Client secret。如果Client secret发生泄露，处于安全考虑，Authorization Server一般允许注册方重新生成secret.</li>
<li>User-Agent：一般指用户浏览器，或者APP。</li>
<li>Access token：是完成授权流程后，Client得到的票据，访问Resource Owner的资源时，需要对其进行验证。认证失败Authorization Server将引导Client重新进行OAuth流程。</li>
<li>Refresh token：类似 AccessToken 的票据，用于刷新Access token（不需要重新走OAuth流程）。Refresh token 是可选项，不一定要实现。</li>
</ol>
<p>熟悉这些概念后，我们开始介绍OAuth2.0定义的标准授权流程。</p>
<h2 id="OAuth2-0-Flow"><a href="#OAuth2-0-Flow" class="headerlink" title="OAuth2.0 Flow"></a>OAuth2.0 Flow</h2><p>以下几种OAuth Flow，摘选自RFC相关文档，详情请参考最后引用链接。</p>
<p>为覆盖各种场景，OAuth2.0划分了4种授权流程：</p>
<ol>
<li>Authorization Code：授权码模式，因为需要在各个节点往返三次，俗称3 leg。</li>
<li>Implicit：隐式授权，相对于授权码模式做了简化。 </li>
<li>Resource Owner Password Credentials：密码认证模式。</li>
<li>Client Credentials：客户端认证模式。</li>
</ol>
<p>下面详细介绍这几种模式。</p>
<h3 id="Authorization-Code-Grant"><a href="#Authorization-Code-Grant" class="headerlink" title="Authorization Code Grant"></a>Authorization Code Grant</h3><p>下图描述了一个完整的 Authorization Code 模式授权流程，Client与其他角色的交互通过User-Agent，这里 Client 包含前端和后端服务器。</p>
<pre><code>+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier      +---------------+
|         -+----(A)-- &amp; Redirection URI ----&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----(B)-- User authenticates ---&gt;|     Server    |
|          |                                 |               |
|         -+----(C)-- Authorization Code ---&lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 (A)  (C)                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&gt;---(D)-- Authorization Code ---------&apos;      |
|  Client |          &amp; Redirection URI                  |
|         |                                             |
|         |&lt;---(E)----- Access Token -------------------&apos;
+---------+       (w/ Optional Refresh Token)
</code></pre><ol>
<li>步骤A：用户在通过User-Agent(浏览器)使用Client时，Client需要访问用户Resource Owner的资源，此时发起了OAuth流程。Client携带客户端认证信息（Client id）、请求资源的范围、本地状态，重定向地址等重定向到Authorization Server，用户看到授权确认页面。</li>
<li>步骤B：用户认证并确认授权信息，Authorization Server判断用户是否合法来进行下一步授权或者返回错误。</li>
<li>步骤C：如果用户合法且同意授权，Authorization Server使用第一步Client提交的重定向地址重定向浏览器，并携带授权码和之前Client提供的本地状态信息。</li>
<li>步骤D：Client 使用授权码找Authorization Server交换access token(处于安全性考虑，一般由Client 的服务端发起)，为了严格验证，这一步除了携带授权码，还需要前面使用的重定向地址。</li>
<li>步骤E：Authorization Server 验证Client提交的授权码是否有效，重定向地址是否与步骤C匹配。如果验证通过，将返回access token和refresh token（可选）给Client。</li>
</ol>
<p>得到 access token后，Client可以在token失效前，访问Resource Server得到已授权的用户资源。OAuth2.0在Client与Resource Server之间，设置了一个授权层（authorization layer），Client 通过得到的授权令牌访问资源，对于资源访问权限、时效在颁发令牌时控制。</p>
<p>流程中几个步骤涉及到的接口：</p>
<p>重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">response_type</td>
<td style="text-align:left">表示授权类型，必选项，此处的值固定为”code”</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">表示客户端的ID，必选项</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，可选项。如果不提供，Authorization Server会使用Client注册时的重定向URI进行重定向。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示申请的权限范围，可选项，多个scope值用空格分开</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。建议使用。</td>
</tr>
</tbody>
</table>
<p>重定向回Client（步骤C）</p>
<p>请求例子：</p>
<pre><code>HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left">表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。建议使用。</td>
</tr>
</tbody>
</table>
<p>从 Authorization Server 获取token（步骤D）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</td>
</tr>
<tr>
<td style="text-align:left">code</td>
<td style="text-align:left">表示上一步获得的授权码，必选项。</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">Client在Authorization Server注册后得到的client_id，必选项。</td>
</tr>
</tbody>
</table>
<p>Authorization Server 返回token（步骤E）</p>
<p>响应结果例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">access_token</td>
<td style="text-align:left">表示访问令牌，必选项。</td>
</tr>
<tr>
<td style="text-align:left">token_type</td>
<td style="text-align:left">表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</td>
</tr>
<tr>
<td style="text-align:left">expires_in</td>
<td style="text-align:left">表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left">refresh_token</td>
<td style="text-align:left">表示更新令牌，用来获取下一次的访问令牌，可选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，如果与客户端申请的范围一致，此项可省略。</td>
</tr>
</tbody>
</table>
<h3 id="Implicit-Grant"><a href="#Implicit-Grant" class="headerlink" title="Implicit Grant"></a>Implicit Grant</h3><p>Implicit 授权的流程如下图，与 Authorization Code 相比，少了返回授权码这一步，Authorization Server直接返回token至Client的前端，Client方面没有后端参与。图中的Web-Hosted Client Resource可以认为是Client的前端资源容器，比如前端服务器，APP等。</p>
<pre><code>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     ^
     |
    (B)
+----|-----+          Client Identifier     +---------------+
|         -+----(A)-- &amp; Redirection URI ---&gt;|               |
|  User-   |                                | Authorization |
|  Agent  -|----(B)-- User authenticates --&gt;|     Server    |
|          |                                |               |
|          |&lt;---(C)--- Redirection URI ----&lt;|               |
|          |          with Access Token     +---------------+
|          |            in Fragment
|          |                                +---------------+
|          |----(D)--- Redirection URI ----&gt;|   Web-Hosted  |
|          |          without Fragment      |     Client    |
|          |                                |    Resource   |
|     (F)  |&lt;---(E)------- Script ---------&lt;|               |
|          |                                +---------------+
+-|--------+
  |    |
 (A)  (G) Access Token
  |    |
  ^    v
+---------+
|         |
|  Client |
|         |
+---------+
</code></pre><ol>
<li>步骤A：与 Authorization Code流程类似，Client携带客户端认证信息（Client id 和 Secret）、请求资源的范围、本地状态，重定向地址等重定向到Authorization Server，用户看到授权确认页面。</li>
<li>步骤B：用户认证并确认授权信息，Authorization Server判断用户是否合法来进行下一步授权或者返回错误。</li>
<li>步骤C：如果用户合法且同意授权，Authorization Server使用第一步Client提交的重定向地址重定向浏览器，并将token携带在URI Fragment中一并返回。</li>
<li>步骤D：User-Agent 顺着重定向指示向Web-Hosted Client Resource 发起请求（按RFC2616该请求不包含Fragment）。User-Agent 在本地保留Fragment信息。</li>
<li>步骤E：Web-Hosted Client Resource 返回一个网页（通常是带有嵌入式脚本的HTML），该网页能够提取URI中的Fragment和其他参数。</li>
<li>步骤F：在User-Agent中使用上一步提供的脚本提取URL中的token。</li>
<li>步骤G：User-Agent传送token给Client。</li>
</ol>
<p>Implicit 比起 Authorization Code 来说，少了Client使用授权码换Token的过程，而是直接把token提供给User-Agent让Client提取。整个流程中使用URL传递token，不需要Client的服务端参与，且没有严格验证Client信息，安全性欠佳。使用这个方式授权，需要在安全性和便利性之间做好权衡。</p>
<p>流程中几个步骤涉及到的接口：</p>
<p>重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
Host: server.example.com
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">response_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”token”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">client_id</td>
<td style="text-align:left">表示客户端的ID，必选项</td>
</tr>
<tr>
<td style="text-align:left">redirect_uri</td>
<td style="text-align:left">表示重定向URI，可选项。如果不提供，Authorization Server会使用Client注册时的重定向URI进行重定向。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示申请的权限范围，可选项，多个scope值用空格分开</td>
</tr>
<tr>
<td style="text-align:left">state</td>
<td style="text-align:left">表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</td>
</tr>
</tbody>
</table>
<p>携带token重定向回Client（步骤C）</p>
<p>请求例子：</p>
<pre><code>HTTP/1.1 302 Found
Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">access_token</td>
<td style="text-align:left">表示访问令牌，必选项。</td>
</tr>
<tr>
<td style="text-align:left">token_type</td>
<td style="text-align:left">表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</td>
</tr>
<tr>
<td style="text-align:left">expires_in</td>
<td style="text-align:left">表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，如果与客户端申请的范围一致，此项可省略。</td>
</tr>
</tbody>
</table>
<p>Implicit Grant  不严格验证Client，因此这里不提供 refresh_token（以防Client不经用户同意，使用refresh_token不断得到授权）。同时Implicit Grant 的access_token 是通过url的hash返回的，不会在网络上传输，但是还是存在泄漏的可能（如User-Agent本身不安全）。</p>
<h3 id="Resource-Owner-Password-Credentials-Grant"><a href="#Resource-Owner-Password-Credentials-Grant" class="headerlink" title="Resource Owner Password Credentials Grant"></a>Resource Owner Password Credentials Grant</h3><p>这种授权方式其实是常见的用户名密码认证方式。使用这种授权的Client必须是高度可信的，比如操作系统。只有当其他的流程不能使用时，才启用这种方式，同时Authorization Server必须特别关注Client确保不会出现安全问题。整个过程中，Client不得保存用户的密码（只能由Client来保证，所以Client必须是高度可信的）。</p>
<pre><code>+----------+
| Resource |
|  Owner   |
|          |
+----------+
     v
     |    Resource Owner
    (A) Password Credentials
     |
     v
+---------+                                  +---------------+
|         |&gt;--(B)---- Resource Owner -------&gt;|               |
|         |         Password Credentials     | Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(C)---- Access Token ---------&lt;|               |
|         |    (w/ Optional Refresh Token)   |               |
+---------+                                  +---------------+
</code></pre><ol>
<li>步骤A：resource owner 提供给Client用户名密码。</li>
<li>步骤B：Client直接使用用户名密码向Authorization Server进行认证，并请求token。</li>
<li>步骤C：Authorization Server认证Client信息和用户名密码，验证通过后返回token。</li>
</ol>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client提交用户名密码请求token（步骤B）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username=johndoe&amp;password=A3ddj3w
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”password”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">username</td>
<td style="text-align:left">表示用户名，必选项。</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">表示用户的密码，必选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，可选项。</td>
</tr>
</tbody>
</table>
<p>Authorization Server返回token信息（步骤C）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式是一样的。</p>
<h3 id="Client-Credentials-Grant"><a href="#Client-Credentials-Grant" class="headerlink" title="Client Credentials Grant"></a>Client Credentials Grant</h3><p>该模式是Client 访问实现与Authorization Server约定好的资源。Client以自己的名义，而不是以用户的名义，向Authorization Server进行认证。严格地说，Client Credentials 模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向Client注册，Client以自己的名义要求Authorization Server提供服务，其实不存在授权问题。</p>
<pre><code>+---------+                                  +---------------+
|         |                                  |               |
|         |&gt;--(A)- Client Authentication ---&gt;| Authorization |
| Client  |                                  |     Server    |
|         |&lt;--(B)---- Access Token ---------&lt;|               |
|         |                                  |               |
+---------+                                  +---------------+
</code></pre><ol>
<li>步骤A：Client 向Authorization Server进行身份认证，并请求token。</li>
<li>步骤B：Authorization Server 对 Client信息进行认证，有效则发放token。</li>
</ol>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client申请token（步骤A）</p>
<p>请求例子：</p>
<pre><code>POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
</code></pre><p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grant_type</td>
<td style="text-align:left">表示授权类型，此处的值固定为”client_credentials”，必选项。</td>
</tr>
<tr>
<td style="text-align:left">scope</td>
<td style="text-align:left">表示权限范围，可选项。</td>
</tr>
</tbody>
</table>
<p>这一步Authorization Server 必须验证Client。</p>
<p>Authorization Server返回token信息（步骤B）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式也是一样的。</p>
<h3 id="PKCE-Proof-Key-for-Code-Exchange"><a href="#PKCE-Proof-Key-for-Code-Exchange" class="headerlink" title="PKCE(Proof Key for Code Exchange)"></a>PKCE(Proof Key for Code Exchange)</h3><p>随着无服务端移动应用或SPA的流行，IETF针对Implicit授权提出了优化方案，在RFC-6749的四种Flow之外另外定义了一种更安全的PKCE模式（RFC-7636）。<br>PKCE的流程大概如下:</p>
<pre><code>                                          +-------------------+
                                          |   Authz Server    |
+--------+                                | +---------------+ |
|        |--(A)- Authorization Request ----&gt;|               | |
|        |       + t(code_verifier), t_m  | | Authorization | |
|        |                                | |    Endpoint   | |
|        |&lt;-(B)---- Authorization Code -----|               | |
|        |                                | +---------------+ |
| Client |                                |                   |
|        |                                | +---------------+ |
|        |--(C)-- Access Token Request ----&gt;|               | |
|        |          + code_verifier       | |    Token      | |
|        |                                | |   Endpoint    | |
|        |&lt;-(D)------ Access Token ---------|               | |
+--------+                                | +---------------+ |
</code></pre><p>这里引入了几个新的变量：t_m（摘要算法），code_verifier，code_challenge（即图中经过算法t_m计算后得到的t(code_verifier)参数）</p>
<ol>
<li>Client随机生成一串字符并作URL-Safe的Base64编码处理, 结果用作code_verifier。</li>
<li>将这串字符通过SHA256哈希，并用URL-Safe的Base64编码处理，结果用作code_challenge。</li>
<li>Client使用把code_challenge，请求Authorization Server，获取Authorization Code。（步骤A）</li>
<li>Authorization Server 认证成功后，返回Authorization Code（步骤B）。</li>
<li>Client 把Authorization Code 和code_verifier请求Authorization Server，换取Access Token。</li>
<li>Authorization Server 返回 token。（步骤D）</li>
</ol>
<p><strong>由于中间人不能由code_challenge逆推code_verifier，因此即使中间人截获了code_challenge, Authorization Code等，也无法换取Access Token, 避免了implicit模式的安全问题。</strong></p>
<p>流程中几个步骤涉及到的接口：</p>
<p>Client重定向授权页（步骤A）</p>
<p>请求例子：</p>
<pre><code>https://{authorizationServerDomain}/oauth2/default/v1/authorize?client_id=0oabygpxgk9l
XaMgF0h7&amp;response_type=code&amp;scope=openid&amp;redirect_uri=yourApp%3A%2Fcallback&amp;st
ate=state-8600b31f-52d1-4dca-987c-386e3d8967e9&amp;code_challenge_method=S256&amp;code_
challenge=qjrzSW9gMiUgpUvqgEPE4_-8swvyCtfOVvg55o5S_es
</code></pre><p>response_type，client_id，redirect_uri，scope，state 跟implicit 模式是一样的。重点看下其他几个参数。</p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parameter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">code_verifier</td>
<td style="text-align:left">一串用来加密的 43 位到 128 位的随机字符串。由 A-Z，a-z，0-9，还有符号 -._~ 生成。</td>
</tr>
<tr>
<td style="text-align:left">code_challenge</td>
<td style="text-align:left">由 code_verifier 来生成，如果设备支持加密，则加密方式为：BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))。如果不支持，则直接使用 code_verifier。</td>
</tr>
<tr>
<td style="text-align:left">code_challenge_method</td>
<td style="text-align:left">生成 code_challenge 所用方法，分为 SHA256 和 plain。前者是指 SHA256 方法加密生成，后者是指直接使用 code_verifier，即不加密。</td>
</tr>
</tbody>
</table>
<p>Authorization Server返回token信息（步骤B）</p>
<p>响应例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"access_token"</span>:<span class="string">"2YotnFZFEjr1zCsicMWpAA"</span>,</span><br><span class="line">   <span class="attr">"token_type"</span>:<span class="string">"example"</span>,</span><br><span class="line">   <span class="attr">"expires_in"</span>:<span class="number">3600</span>,</span><br><span class="line">   <span class="attr">"refresh_token"</span>:<span class="string">"tGzv3JOkF0XG5Qx2TlKWIA"</span>,</span><br><span class="line">   <span class="attr">"example_parameter"</span>:<span class="string">"example_value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的响应参数跟Authorization Code 模式也是一样的。</p>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>对于token（Access Token和Refresh Token）需要使用什么样的格式，其实没有硬性要求，不同平台有不同的实现方式。这里列举两种常见的token规范，Bearer Token和JWT。</p>
<h3 id="Bearer-Token"><a href="#Bearer-Token" class="headerlink" title="Bearer Token"></a>Bearer Token</h3><p>OAuth 诞生时就已经定义了两种token格式：Bearer Token 和 Mac Token，Mac 主要使用在无https的环境下，由于OAuth2.0已经要求所有参与者必须使用HTTPS，所以Mac格式不在我们今天讨论范围。Bearer Token由RFC-6750定义。</p>
<p>Bearer Token 格式用BNF范式表示就是：</p>
<pre><code>b64token    = 1*( ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;
credentials = &quot;Bearer&quot; 1*SP b64token
</code></pre><p>换成程序员比较容易理解的正则表达式就是：</p>
<pre><code>b64token = [0-9a-zA-Z-._~+/]+=
credentials =  Bearer\s([0-9a-zA-Z-._~+/]+=)+
</code></pre><p>所以所谓的Bearer Token就是以数字、大小写字母、破折号、小数点、下划线、波浪线、加号、正斜杠、等号结尾组成的Base64编码字符串。在HTTP传输过程中，需要以’Bearer ‘作为前缀标识。</p>
<p><strong>Bearer Token 的三种传输方式</strong></p>
<p>RFC-6750定义了三种传输Bearer Token 的方式，优先级依次递减：</p>
<p><strong>Authorization Request Header Field（使用HTTP Header的Authorization字段传递）</strong></p>
<pre><code>GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM
</code></pre><p><strong>Form-Encoded Body Parameter（使用表单参数传递）</strong></p>
<pre><code>POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=mF_9.B5f-4.1JqM
</code></pre><p><strong>URI Query Parameter（使用URI参数传递）</strong></p>
<pre><code>GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1
Host: server.example.com
</code></pre><p>由于Cookie容易被CSRF攻击，不建议采用cookie的方式传输token。<br>尽量不要用URI参数的方法，因为浏览器历史记录、服务器日志等可能泄露URI上的机密信息。</p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（JSON Web Token）是近几年移动端常用的token，它可以直接将一些信息编码传递，对客户端更友好。使用JWT有以下有点：</p>
<ol>
<li>验证token 不需要另外的缓存或者数据库，通过约定好的加密方式解密就行。</li>
<li>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</li>
<li>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>
<li>它不需要在服务端保存会话信息, 所以它易于应用的扩展。</li>
</ol>
<p>使用JWT也必须注意一些问题：</p>
<ol>
<li>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</li>
<li>保护好secret私钥，该私钥非常重要。</li>
<li>如果可以，请使用https协议传递JWT。</li>
</ol>
<p>JWT也有自己的RFC规范RFC-7519，这里简单介绍一下它的格式。详细请参考文末的RFC链接。</p>
<p><img src="Untitled-2a5aa9d0-2e52-43d2-9a74-ef24c45f72ac.png" alt></p>
<p>JWT的格式很简单，一个JWT字符串分为Header，Payload，Signature三部分，他们的原始字符串经过编码后由小数点分隔连接起来。</p>
<p>Header记录着token类型和摘要算法，这里的明文最后要经过Base64URL编码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Payload记录着业务信息和用户数据（非敏感），字段可以根据需求自定义，<strong>处于安全性考虑，实现方会再加上expire过期时间字段控制生命周期</strong>。这里的明文同样也要经过Base64URL编码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Signature是Header和Payload经过摘要算法处理后的签名信息，使用的摘要算法需要同Header中alg属性一致，这里是HS256。secret是加密需要的密钥，使用对称加密算法的话密钥泄漏影响较大。如果使用非对称加密算法（如RSA256），使用的是公钥验证签名，风险就小很多：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + "." +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>连接编码后的三个部分，就得到一个JWT字符串：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM
</code></pre><p>所以当Server端颁发JWT后，Client就可以根据约定好的secret，摘要算法验证Signature并提取Payload信息。</p>
<h2 id="OAuth-面临的安全问题"><a href="#OAuth-面临的安全问题" class="headerlink" title="OAuth 面临的安全问题"></a>OAuth 面临的安全问题</h2><p>OAuth2.0 作为一个授权协议，安全问题尤为重要。OAuth大规模应用的这些年来，主要的安全问题可以分为以下几类：</p>
<ol>
<li>Client Authentication（客户端错误认证），作为Client的开发者，必须保护好自己的client_id client_secret，谨防盗用。</li>
<li>Code or Token Steal（票据窃取），OAuth 是票据协议，无法区分使用票据的人是否合法。所以作为Authorization Server，必须对token的失效机制做好控制(如合理的失效时间，限制Code只能用一次，允许用户管理自己已授权的token)。作为Client，必须确保用户授权的token不被采集（最常见的问题就是在log中记录access token）</li>
<li>Cross-Site Request Forgery(CSRF攻击)，Authorization Code Grant模式流程较长，存在CSRF隐患。</li>
<li>Authorization Code Redirection URI Manipulation（重定向地址篡改），重定向地址篡改是钓鱼网站常用的攻击手段。</li>
</ol>
<p>前面两种是任何认证授权系统都需要考虑的安全问题，这里重点介绍下后面两种跟OAuth流程比较相关的安全问题。</p>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>在OAuth2.0流程中实施CSRF攻击的流程如下：</p>
<p><img src="Untitled-4dc8306d-39bc-4d5d-937c-2e4ae4645294.png" alt></p>
<p><strong>原理</strong></p>
<ol>
<li>攻击者预先准备好使用自己账号授权生成的 authorization code 的回调地址，引诱用户点击。</li>
<li>用户点击后，变成使用攻击者的账号完成Oauth 流程得到token。</li>
<li>在的第三方app绑定账号的场景，攻击者就可以使用自己的账号完成OAuth登陆用户的第三方app。</li>
</ol>
<p><strong>防范措施</strong></p>
<p>要防止这样的攻击其实很容易，使用RFC规范中推荐的state参数即可，但是由于增加了开发工作量，很多开发者使用OAuth2.0时，经常忽略这个参数。具体细节如下：</p>
<ol>
<li>在 Authorization Code Grant或者implicit Grant流程的第一步，调用/authorize接口时，带上state参数，state的值由Client指定，生成规则需保证足够随机又有一定业务含义，他人无法轻易假冒。</li>
<li>Client 需要保存state参数。</li>
<li>在Authorization Server 认证成功重定向回Client时，会将state原样带回，此时Client需要验证state参数是否一致。</li>
</ol>
<h3 id="Authorization-Code-流程重定向地址篡改"><a href="#Authorization-Code-流程重定向地址篡改" class="headerlink" title="Authorization Code 流程重定向地址篡改"></a>Authorization Code 流程重定向地址篡改</h3><p><img src="Untitled-c5f08367-0a87-4b30-a497-d1194581e665.png" alt></p>
<p>对重定向地址检查也是一个时常被忽略的安全弱点。</p>
<p><strong>原理</strong></p>
<ol>
<li>对于一个正常的第三方Client应用A，攻击者自己也作为一个Client，伪造一个应用A的/authorize请求的链接，其中redirect_uri指向的是攻击者的Client。</li>
<li>攻击者诱导用户点击伪造的链接，发起OAuth2.0的Authorization Code Grant流程。</li>
<li>用户完成认证后，Authorization Server 携带Code重定向回攻击者Client。</li>
<li>攻击者准备一个自己的Code，将上一步应用A的Code替换，伪造一条应用A的回调请求返回给应用A。（此时Code被替换成了攻击者的Code）</li>
<li>应用A的Client在不清楚Code被替换的情况下，继续完成Authorization Code Grant流程，使用攻击者的Code换取Access Token。</li>
</ol>
<p>此时用户走完OAuth流程，但是在应用A上得到的却是攻击者帐号的授权。大家会觉得，这样有什么问题，又不是用户的授权泄漏。这种攻击方式可以针对绑定帐号的场景，比如用户本来要将豆瓣帐号与微博帐号关联，使用微博的OAuth授权来登陆豆瓣。而被这样钓鱼以后，自己的豆瓣帐号绑定的是攻击者的微博帐号，此时攻击者就可以用他的微博帐号登陆用户的豆瓣帐号了。</p>
<p><strong>防范方法</strong></p>
<ol>
<li>Client 注册时，需要开发者提供域名与Client绑定。</li>
<li>Authorization Server对/authorize 接口验证的redirect_uri 参数验证，确认与Client注册时提供的域名一致。</li>
<li>Authorization Server对/access_token 接口的redirect_uri 参数进行验证，保证与Client发起 /authorize请求时的redirect_uri一致。</li>
<li>对于Authorization Server的Code换token接口，可以要求Client提供client_id和secret，校验此时的code是否产生自同一个client_id。</li>
</ol>
<p>对于上面提到的CSRF和钓鱼攻击，Client方面如果增加一些授权成功后的提示给用户（比如平台成功与xxx帐号绑定），可以避免用户无意识地授权的情况发生。上面的例子只是简单展示了OAuth授权中需要开发者关注的安全细节，关于OAuth安全想要了解更多，可以参考文末的OAuth安全指南。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>OAuth2.0 规范将参与者划分为 Resource Owner，Resource Server，Client，Authorization Server四种角色。</li>
<li>RFC-6749定义了四种OAuth2.0 Grant Flow：Authorization Code Grant，Implicit Grant，Resource Owner Password Credentials Grant，Client Credentials Grant。其中前两种是比较常用的OAuth2.0授权模式。</li>
<li>对于移动端APP或者SPA应用，可以考虑使用PKCE模式减少Implicit Grant的安全风险。</li>
<li>对于Token的格式，建议使用Bearer Token或者JWT。</li>
<li>由于OAuth2.0的Flow步骤较长，不管是Client端还是Authorization Server端，在使用OAuth2.0的时候，最好严格按照RFC规范执行，可以最大程度地减少安全隐患。同时也要注意业界关于OAuth漏洞的披露，及时修复漏洞。</li>
</ol>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li>OAuth2.0: <a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a></li>
<li>OAuth2.0(RFC-6749): <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a></li>
<li>PKCE(RFC-7636): <a href="https://tools.ietf.org/html/rfc7636" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7636</a></li>
<li>Bearer token(RFC-6750): <a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6750</a></li>
<li>JWT(RFC-7519): <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a></li>
<li>乌云平台（备份）OAuth安全指南: <a href="http://drops.xmd5.com/static/drops/papers-1989.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/papers-1989.html</a></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/web/" rel="tag"># web</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/20/Effective Java 3rd edition 读书笔记/" rel="prev" title="Effective Java 3rd edition 读书笔记">
      <i class="fa fa-chevron-left"></i> Effective Java 3rd edition 读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/06/15/关于方法论/" rel="next" title="关于方法论">
      关于方法论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-OAuth"><span class="nav-number">1.</span> <span class="nav-text">What is OAuth</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth历史"><span class="nav-number">2.</span> <span class="nav-text">OAuth历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些概念"><span class="nav-number">3.</span> <span class="nav-text">一些概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#角色"><span class="nav-number">3.1.</span> <span class="nav-text">角色</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#几个术语"><span class="nav-number">3.2.</span> <span class="nav-text">几个术语</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth2-0-Flow"><span class="nav-number">4.</span> <span class="nav-text">OAuth2.0 Flow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Authorization-Code-Grant"><span class="nav-number">4.1.</span> <span class="nav-text">Authorization Code Grant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implicit-Grant"><span class="nav-number">4.2.</span> <span class="nav-text">Implicit Grant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource-Owner-Password-Credentials-Grant"><span class="nav-number">4.3.</span> <span class="nav-text">Resource Owner Password Credentials Grant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-Credentials-Grant"><span class="nav-number">4.4.</span> <span class="nav-text">Client Credentials Grant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PKCE-Proof-Key-for-Code-Exchange"><span class="nav-number">4.5.</span> <span class="nav-text">PKCE(Proof Key for Code Exchange)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Token"><span class="nav-number">5.</span> <span class="nav-text">Token</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bearer-Token"><span class="nav-number">5.1.</span> <span class="nav-text">Bearer Token</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JWT"><span class="nav-number">5.2.</span> <span class="nav-text">JWT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth-面临的安全问题"><span class="nav-number">6.</span> <span class="nav-text">OAuth 面临的安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF攻击"><span class="nav-number">6.1.</span> <span class="nav-text">CSRF攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Authorization-Code-流程重定向地址篡改"><span class="nav-number">6.2.</span> <span class="nav-text">Authorization Code 流程重定向地址篡改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">7.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-number">8.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tachikoma</p>
  <div class="site-description" itemprop="description">Less is more</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tachikoma</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
